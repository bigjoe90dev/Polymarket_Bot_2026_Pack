================================================================================
POLYMARKET BOT — LLM REVIEW PACK
Generated: 2026-02-08 20:12:23
================================================================================

PURPOSE: This export contains the complete source code, configuration, and
trading data from a Polymarket copy-trading bot running in PAPER mode.
Please analyse for:
1. Bugs or logic errors in the trading pipeline
2. Whether the paper trading simulation is realistic
3. Risk management gaps
4. Whether the PnL results are credible or artificially inflated
5. Suggestions for improvement before going live
6. Any potential issues that could cause losses in live trading


================================================================================
SECTION: SOURCE CODE
================================================================================

--- FILE: src/__init__.py ---


--- FILE: src/backtester.py ---
"""Backtesting engine — replays collected order book snapshots against strategy variants.

Usage:
    from src.backtester import Backtester
    bt = Backtester("data/snapshots/session_1738800000.jsonl")
    results = bt.compare_strategies([
        {"MIN_PROFIT": 0.01, "COST_BUFFER": 0.005},
        {"MIN_PROFIT": 0.02, "COST_BUFFER": 0.005},
        {"MIN_PROFIT": 0.01, "COST_BUFFER": 0.01},
    ])
"""

import json
import time
from src.data_collector import load_snapshots
from src.paper_fills import simulate_two_leg_fill


class Backtester:
    """Replays order book snapshots to evaluate strategy parameters."""

    def __init__(self, snapshot_file):
        self.snapshots = load_snapshots(snapshot_file)
        self.snapshot_file = snapshot_file
        print(f"[BACKTEST] Loaded {len(self.snapshots)} snapshots from {snapshot_file}")

    def run(self, config):
        """Run a single strategy config against all snapshots.

        Config keys:
            MIN_PROFIT:     Minimum profit threshold per unit (default 0.02)
            COST_BUFFER:    Cost buffer added to spread (default 0.005)
            MIN_LIQUIDITY:  Minimum size at best ask (default 1.0)
            MAX_ORDER_SIZE: Max shares per trade (default 10.0)
            STARTING_BALANCE: Paper balance to start with (default 1000.0)
        """
        min_profit = config.get("MIN_PROFIT", 0.02)
        cost_buffer = config.get("COST_BUFFER", 0.005)
        min_liq = config.get("MIN_LIQUIDITY", 1.0)
        max_size = config.get("MAX_ORDER_SIZE", 10.0)
        balance = config.get("STARTING_BALANCE", 1000.0)
        starting_balance = balance

        trades = []
        opportunities_found = 0
        opportunities_filled = 0
        total_fees = 0.0
        positions = {}  # cid -> total_cost, for tracking exposure
        markets_seen = set()

        for snap in self.snapshots:
            cid = snap.get("cid", "")
            markets_seen.add(cid)

            yes_ask = snap.get("yes_ask")
            no_ask = snap.get("no_ask")
            yes_depth = snap.get("yes_depth", [])
            no_depth = snap.get("no_depth", [])

            if yes_ask is None or no_ask is None:
                continue
            if not yes_depth or not no_depth:
                continue

            # Liquidity check
            best_size_yes = float(yes_depth[0][1]) if yes_depth else 0
            best_size_no = float(no_depth[0][1]) if no_depth else 0
            if best_size_yes < min_liq or best_size_no < min_liq:
                continue

            # Strategy check
            total_unit_cost = yes_ask + no_ask + cost_buffer
            if total_unit_cost >= 1.00:
                continue

            expected_profit = 1.00 - total_unit_cost
            if expected_profit < min_profit:
                continue

            opportunities_found += 1

            # Determine size
            tradeable_size = min(best_size_yes, best_size_no, max_size)

            # Simulate fill against recorded order book
            result = simulate_two_leg_fill(
                yes_depth, no_depth, tradeable_size
            )

            if not result["both_filled"]:
                continue

            total_cost = result["total_cost"]

            # Balance check
            if total_cost > balance:
                continue

            opportunities_filled += 1
            balance -= total_cost
            total_fees += result["yes_fee"] + result["no_fee"]

            # For locked-profit, payout = matched_size * $1 at settlement
            payout = result["matched_size"] * 1.0
            realized_profit = payout - total_cost

            # Add payout back (simulate instant settlement for backtest)
            balance += payout

            trade = {
                "timestamp": snap.get("ts"),
                "condition_id": cid,
                "yes_price": result["yes_fill"]["fill_price"],
                "no_price": result["no_fill"]["fill_price"],
                "size": result["matched_size"],
                "total_cost": round(total_cost, 6),
                "payout": round(payout, 6),
                "profit": round(realized_profit, 6),
                "fees": round(result["yes_fee"] + result["no_fee"], 6),
                "yes_slippage": result["yes_fill"]["slippage"],
                "no_slippage": result["no_fill"]["slippage"],
            }
            trades.append(trade)

        # Compute summary metrics
        total_profit = sum(t["profit"] for t in trades)
        total_slippage = sum(t["yes_slippage"] + t["no_slippage"] for t in trades)
        winning = [t for t in trades if t["profit"] > 0]
        losing = [t for t in trades if t["profit"] <= 0]

        # Time range
        timestamps = [s["ts"] for s in self.snapshots if "ts" in s]
        duration_hours = (max(timestamps) - min(timestamps)) / 3600 if len(timestamps) >= 2 else 0

        return {
            "config": config,
            "snapshot_file": self.snapshot_file,
            "total_snapshots": len(self.snapshots),
            "unique_markets": len(markets_seen),
            "duration_hours": round(duration_hours, 2),
            "opportunities_found": opportunities_found,
            "opportunities_filled": opportunities_filled,
            "fill_rate_pct": round(opportunities_filled / max(opportunities_found, 1) * 100, 1),
            "total_trades": len(trades),
            "winning_trades": len(winning),
            "losing_trades": len(losing),
            "win_rate_pct": round(len(winning) / max(len(trades), 1) * 100, 1),
            "starting_balance": starting_balance,
            "ending_balance": round(balance, 2),
            "total_profit": round(total_profit, 4),
            "total_fees": round(total_fees, 4),
            "net_profit": round(total_profit - total_fees, 4),
            "total_slippage": round(total_slippage, 6),
            "avg_profit_per_trade": round(total_profit / max(len(trades), 1), 6),
            "best_trade": max(trades, key=lambda t: t["profit"], default=None),
            "worst_trade": min(trades, key=lambda t: t["profit"], default=None),
            "trades": trades,
        }

    def compare_strategies(self, configs):
        """Run multiple configs and return comparison."""
        results = []
        for i, cfg in enumerate(configs):
            print(f"[BACKTEST] Running strategy {i+1}/{len(configs)}: {cfg}")
            result = self.run(cfg)
            results.append(result)

        return results

    def generate_report(self, results):
        """Generate a text report comparing strategy results."""
        lines = []
        lines.append("=" * 70)
        lines.append("BACKTEST REPORT")
        lines.append("=" * 70)
        lines.append(f"Snapshot file: {self.snapshot_file}")
        lines.append(f"Total snapshots: {len(self.snapshots)}")
        lines.append("")

        for i, r in enumerate(results):
            lines.append(f"--- Strategy {i+1} ---")
            cfg = r["config"]
            lines.append(f"  Config: MIN_PROFIT={cfg.get('MIN_PROFIT')}, "
                         f"COST_BUFFER={cfg.get('COST_BUFFER')}, "
                         f"MIN_LIQUIDITY={cfg.get('MIN_LIQUIDITY')}, "
                         f"MAX_ORDER_SIZE={cfg.get('MAX_ORDER_SIZE')}")
            lines.append(f"  Duration: {r['duration_hours']}h across {r['unique_markets']} markets")
            lines.append(f"  Opportunities: {r['opportunities_found']} found, "
                         f"{r['opportunities_filled']} filled ({r['fill_rate_pct']}%)")
            lines.append(f"  Trades: {r['total_trades']} "
                         f"({r['winning_trades']}W / {r['losing_trades']}L, "
                         f"{r['win_rate_pct']}% win rate)")
            lines.append(f"  Profit: ${r['total_profit']:.4f} "
                         f"(fees: ${r['total_fees']:.4f}, "
                         f"net: ${r['net_profit']:.4f})")
            lines.append(f"  Avg per trade: ${r['avg_profit_per_trade']:.6f}")
            lines.append(f"  Balance: ${r['starting_balance']:.2f} -> ${r['ending_balance']:.2f}")
            lines.append("")

        # Winner
        if results:
            best = max(results, key=lambda r: r["net_profit"])
            best_idx = results.index(best) + 1
            lines.append(f"BEST STRATEGY: #{best_idx} with ${best['net_profit']:.4f} net profit")

        lines.append("=" * 70)
        return "\n".join(lines)

    def export_for_llm(self, results):
        """Export backtest results in a format optimized for LLM analysis."""
        export = {
            "type": "polymarket_backtest_results",
            "generated_at": time.time(),
            "snapshot_file": self.snapshot_file,
            "total_snapshots": len(self.snapshots),
            "strategies_tested": len(results),
            "results": [],
        }

        for r in results:
            # Strip individual trades for size, keep summary + top/bottom trades
            entry = {k: v for k, v in r.items() if k != "trades"}
            entry["sample_trades"] = r["trades"][:10]  # First 10 for context
            export["results"].append(entry)

        export["analysis_prompt"] = (
            "Analyze these Polymarket arbitrage backtest results. "
            "Compare the strategy configurations and recommend which parameters "
            "to use for a locked-profit arbitrage bot. Consider: trade frequency, "
            "profit per trade, fill rate, and total net profit. "
            "Suggest additional parameters worth testing."
        )

        return export


--- FILE: src/bot.py ---
import time
from src.market import MarketDataService
from src.strategy import check_opportunity
from src.execution import ExecutionEngine
from src.risk import RiskGuard
from src.records import log_decision
from src.health import report_status
from src.data_collector import DataCollector
from src.whale_tracker import WhaleTracker
from src.wallet_scorer import WalletScorer

# Free-infra speed constants (overridable via config)
DEFAULT_MARKETS_PER_CYCLE = 20   # Order books fetched per cycle
CYCLE_SLEEP = 1.0                # Seconds between cycles
MARKET_REFRESH_SECONDS = 120     # Re-fetch full market list every 2 min


class TradingBot:
    def __init__(self, config):
        self.config = config
        self.market = MarketDataService(config)
        self.risk = RiskGuard(config)
        self.execution = ExecutionEngine(config, self.risk, self.market)
        self.running = True
        self._start_time = time.time()
        self._current_markets = []
        self._cycle_count = 0
        self._market_offset = 0  # Rotation pointer into full market list
        self._last_market_refresh = 0
        self._market_heat = {}   # cid -> overround (lower = closer to arb)
        self._fetch_errors = 0   # Silent error counter
        self._copy_trades = 0    # Copy trades executed
        self._copy_exits = 0     # Copy exits executed

        # Configurable speed params
        self._markets_per_cycle = config.get("MARKETS_PER_CYCLE", DEFAULT_MARKETS_PER_CYCLE)

        # Data collection for backtesting
        self.collector = DataCollector(enabled=config.get("COLLECT_DATA", True))

        # Wallet scoring: deep performance tracking + flow analysis
        self.wallet_scorer = WalletScorer(config)

        # Whale tracking for copy trading (with scorer for market filtering)
        self.whale_tracker = WhaleTracker(config, wallet_scorer=self.wallet_scorer)

        # Inject scorer into paper engine if it exists
        if self.execution.paper_engine:
            self.execution.paper_engine.scorer = self.wallet_scorer

    def run(self):
        print("[*] Bot warming up...")
        markets = self.market.get_active_markets()
        self._current_markets = markets
        self._last_market_refresh = time.time()
        print(f"[*] Found {len(markets)} active markets")
        print(f"[*] Speed: {self._markets_per_cycle} markets/cycle, sequential, {CYCLE_SLEEP}s sleep")

        # Discover profitable traders from leaderboard ($3k-$10k/month)
        print("[*] Discovering profitable traders from leaderboard...")
        self.whale_tracker.discover_whales()

        if not markets:
            print("[!] No active markets found. Exiting.")
            return

        while self.running:
            if self.risk.check_kill_switch():
                self.shutdown()
                break

            self._cycle_count += 1

            # Refresh market list every 2 minutes
            now = time.time()
            if now - self._last_market_refresh >= MARKET_REFRESH_SECONDS:
                try:
                    fresh = self.market.get_active_markets()
                    if fresh:
                        markets = fresh
                        self._current_markets = markets
                        self._market_offset = 0
                        self._last_market_refresh = now
                        print(f"[*] Market refresh: {len(markets)} active markets")
                except Exception as e:
                    print(f"[!] Market refresh failed: {e}")

            # ── Dynamic risk limits: scale with account balance ──
            if self.execution.paper_engine:
                pe = self.execution.paper_engine
                self.risk.update_limits(pe.portfolio["cash_balance"], pe.starting_balance)

            # ── Whale tracking: poll one wallet per cycle ─────
            self.whale_tracker.discover_whales()    # No-op if fetched recently
            self.whale_tracker.discover_network()   # No-op if scanned recently
            signals = self.whale_tracker.poll_whale_activity()

            # Execute copy trades + exits in paper mode (crash-proofed)
            if signals and self.execution.paper_engine:
                for signal in signals:
                    try:
                        if signal.get("type") == "COPY_EXIT":
                            # Whale is selling — close our matching position
                            result = self.execution.paper_engine.close_copy_position(
                                signal, risk_guard=self.risk
                            )
                            if result and result.get("success"):
                                self._copy_exits += 1
                        else:
                            # Whale is buying — open a copy position
                            result = self.execution.paper_engine.execute_copy_trade(
                                signal, current_exposure=self.risk.current_exposure
                            )
                            if result and result.get("success"):
                                self._copy_trades += 1
                                self.risk.add_exposure(result.get("total_cost", 0))
                            elif result:
                                title = signal.get("market_title", "")[:40]
                                print(f"[COPY] SKIP: {result.get('reason', '?')} — {title}")
                    except Exception as e:
                        print(f"[!] Copy trade error: {e}")

            # ── Arb scanning: rotate through markets ──────────
            batch = self._get_next_batch(markets)

            for m in batch:
                try:
                    book = self.market.get_order_book(m)
                    if not book:
                        self._fetch_errors += 1
                        continue

                    plan = check_opportunity(book, self.config)
                    self.collector.record(m, book, plan)
                    self._update_heat(m, book)

                    if plan:
                        log_decision(
                            "OPPORTUNITY",
                            f"[{plan['type']}] profit=${plan['expected_profit']:.4f}/unit "
                            f"in {m['condition_id'][:12]}..."
                        )
                        result = self.execution.execute_plan(
                            plan, book=book, market_info=m
                        )
                        if result and result.get("success"):
                            self.risk.add_exposure(result.get("total_cost", 0))

                except Exception:
                    self._fetch_errors += 1
                    continue

            # Paper trading: settlement check and PnL snapshot (crash-proofed)
            try:
                if self.execution.paper_engine:
                    self.execution.paper_engine.check_and_settle_positions(
                        self.market, self.risk
                    )
                    self.execution.paper_engine.record_pnl_snapshot()
            except Exception as e:
                print(f"[!] Settlement/snapshot error: {e}")

            try:
                report_status(self)
            except Exception:
                pass

            # Flush collected data periodically
            if self._cycle_count % 60 == 0:
                self.collector.flush()

            time.sleep(CYCLE_SLEEP)

    def _get_next_batch(self, markets):
        """Get next batch of markets using rotation + heat priority."""
        total = len(markets)
        if total == 0:
            return []

        mpc = self._markets_per_cycle

        # Every 4th cycle: prioritize "hot" markets (lowest overround)
        if self._cycle_count % 4 == 0 and self._market_heat:
            hot = sorted(self._market_heat.items(), key=lambda x: x[1])
            hot_cids = {cid for cid, _ in hot[:mpc]}
            batch = [m for m in markets if m["condition_id"] in hot_cids]
            if len(batch) >= mpc // 2:
                return batch[:mpc]

        # Normal rotation: sliding window through ALL markets
        start = self._market_offset
        end = start + mpc

        if end <= total:
            batch = markets[start:end]
            self._market_offset = end
        else:
            batch = markets[start:] + markets[:end - total]
            self._market_offset = end - total

        return batch

    def _update_heat(self, market, book):
        """Track how close each market is to arbitrage (lower = hotter)."""
        asks_yes = book.get('asks_yes', [])
        asks_no = book.get('asks_no', [])
        if asks_yes and asks_no:
            overround = float(asks_yes[0][0]) + float(asks_no[0][0]) - 1.0
            self._market_heat[market["condition_id"]] = overround

    def shutdown(self):
        print("[!] Shutting down...")
        self.running = False
        self.collector.flush()


--- FILE: src/config.py ---
import os
import json
import getpass
import uuid

CONFIG_PATH = "config/config.json"
CONFIG_VERSION = 9  # Bump to force-upgrade defaults


def load_or_create_config():
    os.makedirs(os.path.dirname(CONFIG_PATH), exist_ok=True)
    config = {}
    if os.path.exists(CONFIG_PATH):
        with open(CONFIG_PATH, "r") as f:
            try: config = json.load(f)
            except: config = {}

    dirty = False

    # Auto-upgrade old configs to aggressive free-infra defaults
    if config.get("_config_version", 0) < CONFIG_VERSION:
        config["_config_version"] = CONFIG_VERSION
        config["MIN_PROFIT"] = 0.003
        config["COST_BUFFER"] = 0.002
        config["MIN_LIQUIDITY"] = 0.5
        config["MAX_ORDER_SIZE"] = 3.0
        config["MARKETS_PER_CYCLE"] = 20
        config["FETCH_WORKERS"] = 4
        config["COPY_TRADE_SIZE"] = 2.0
        config["COPY_RATIO"] = 0.01          # Copy 1% of whale's trade size
        # ── Dynamic percentage-based risk (scales with balance) ──
        config["RISK_PER_TRADE_PCT"] = 0.01   # 1% of balance per trade (minimum)
        config["RISK_MAX_TRADE_PCT"] = 0.03   # 3% of balance per trade (maximum)
        config["RISK_MAX_MARKET_PCT"] = 0.06  # 6% of balance per market
        config["RISK_MAX_EXPOSURE_PCT"] = 0.50  # 50% of balance total exposure
        config["RISK_MAX_DAILY_LOSS_PCT"] = 0.30  # 30% of balance daily loss
        # Fallback fixed values (used by RiskGuard init before dynamic update)
        config["MAX_EXPOSURE"] = 25.0
        config["MAX_DAILY_LOSS"] = 15.0
        config["TAKE_PROFIT_PCT"] = 0.15     # Sell when position is +15% profit
        config["STOP_LOSS_PCT"] = 0.25       # Sell when position is -25% loss
        dirty = True
        print("[*] Config v9 — Dynamic risk: 1-3% per trade, scales with growth")

    # Select mode FIRST so we know whether credentials are needed
    if "MODE" not in config:
        print("\nSelect Mode:")
        print("1. Paper (Simulate only)")
        print("2. Shadow (Watch live, no orders)")
        print("3. Live (Real money)")
        sel = input("Choice [1]: ").strip() or "1"
        config["MODE"] = {"1": "PAPER", "2": "SHADOW", "3": "LIVE"}.get(sel, "PAPER")
        dirty = True

    # API credentials — PAPER mode doesn't need real keys
    if not config.get("POLY_API_KEY"):
        if config["MODE"] == "PAPER":
            config["POLY_API_KEY"] = "paper-mode"
            config["POLY_SECRET"] = "paper-mode"
            config["POLY_PASSPHRASE"] = "paper-mode"
        else:
            print("\n[!] API Key missing. Please provide Polymarket credentials.")
            config["POLY_API_KEY"] = getpass.getpass("Enter Polymarket API Key: ").strip()
            config["POLY_SECRET"] = getpass.getpass("Enter Polymarket Secret: ").strip()
            config["POLY_PASSPHRASE"] = getpass.getpass("Enter Polymarket Passphrase: ").strip()
        dirty = True

    if "MAX_EXPOSURE" not in config:
        config["MAX_EXPOSURE"] = 50.0
        dirty = True

    # Private key only required for LIVE trading (order signing)
    # ────────────────────────────────────────────────────────────────
    # LIVE MODE SETUP: You need a Polygon wallet with USDC.
    #   Option A — Rabby Wallet (recommended):
    #     1. Install Rabby browser extension (rabby.io)
    #     2. Create/import a wallet on Polygon network
    #     3. Fund with USDC on Polygon
    #     4. Export private key from Rabby: Settings → Manage Address → Export
    #     5. Paste the hex private key below when prompted
    #   Option B — MetaMask: Same steps, export from Account Details
    #   IMPORTANT: This key signs on-chain orders. Keep it safe.
    #              NEVER share it or commit it to source control.
    # ────────────────────────────────────────────────────────────────
    if config["MODE"] == "LIVE" and not config.get("POLY_PRIVATE_KEY"):
        print("\n[!] LIVE mode requires a private key for signing orders.")
        print("    Export from Rabby: Settings → Manage Address → Export Private Key")
        print("    Or from MetaMask: Account Details → Export Private Key")
        config["POLY_PRIVATE_KEY"] = getpass.getpass("Enter Polymarket Private Key (hex): ").strip()
        dirty = True

    # Paper trading settings
    if "PAPER_BALANCE" not in config:
        config["PAPER_BALANCE"] = 50.0
        dirty = True

    if "WEB_PORT" not in config:
        config["WEB_PORT"] = 8080
        dirty = True

    # Data collection (for backtesting)
    if "COLLECT_DATA" not in config:
        config["COLLECT_DATA"] = True
        dirty = True

    # Dashboard security: auto-generate access token
    if "DASHBOARD_TOKEN" not in config:
        config["DASHBOARD_TOKEN"] = uuid.uuid4().hex[:16]
        dirty = True
        print(f"[*] Dashboard token generated (required for access)")

    # Dashboard bind: 127.0.0.1 = local only, 0.0.0.0 = network/cloud
    if "DASHBOARD_BIND" not in config:
        config["DASHBOARD_BIND"] = "127.0.0.1"
        dirty = True

    # Free tier (no infra simulation)
    config["INFRA_TIER"] = 1

    if dirty:
        with open(CONFIG_PATH, "w") as f:
            json.dump(config, f, indent=2)

    return config


--- FILE: src/data_collector.py ---
"""Data collector for order book snapshots and strategy decisions.

Records every market scan cycle so the data can be replayed
by the backtester or exported for LLM analysis.

Data format (JSONL — one JSON object per line):
{
  "ts": 1738800000.0,
  "cid": "0xabc...",
  "yes_ask": 0.45,   "no_ask": 0.52,
  "yes_bid": 0.44,   "no_bid": 0.51,
  "yes_depth": [[0.45, 100], [0.46, 50]],
  "no_depth":  [[0.52, 80], [0.53, 40]],
  "spread": 0.03,
  "opp": null | { plan dict }
}
"""

import os
import json
import time


SNAPSHOT_DIR = "data/snapshots"


class DataCollector:
    """Records order book snapshots to JSONL files for backtesting."""

    def __init__(self, enabled=True):
        self.enabled = enabled
        self._buffer = []
        self._flush_interval = 30  # seconds
        self._last_flush = time.time()
        self._snap_count = 0

        if self.enabled:
            os.makedirs(SNAPSHOT_DIR, exist_ok=True)
            self._filepath = os.path.join(
                SNAPSHOT_DIR,
                f"session_{int(time.time())}.jsonl"
            )
            print(f"[DATA] Recording snapshots to {self._filepath}")

    def record(self, market, book, opportunity=None):
        """Record a single order book observation."""
        if not self.enabled or not book:
            return

        asks_yes = book.get("asks_yes", [])
        asks_no = book.get("asks_no", [])
        bids_yes = book.get("bids_yes", [])
        bids_no = book.get("bids_no", [])

        snap = {
            "ts": round(time.time(), 2),
            "cid": market.get("condition_id", ""),
            "yes_ask": float(asks_yes[0][0]) if asks_yes else None,
            "no_ask": float(asks_no[0][0]) if asks_no else None,
            "yes_bid": float(bids_yes[0][0]) if bids_yes else None,
            "no_bid": float(bids_no[0][0]) if bids_no else None,
            "yes_depth": [[float(a[0]), float(a[1])] for a in asks_yes[:5]],
            "no_depth": [[float(a[0]), float(a[1])] for a in asks_no[:5]],
            "yes_bid_depth": [[float(b[0]), float(b[1])] for b in bids_yes[:5]],
            "no_bid_depth": [[float(b[0]), float(b[1])] for b in bids_no[:5]],
        }

        # Add spread calculation
        if snap["yes_ask"] is not None and snap["no_ask"] is not None:
            snap["spread"] = round(snap["yes_ask"] + snap["no_ask"] - 1.0, 6)
        else:
            snap["spread"] = None

        # Record strategy decision
        if opportunity:
            snap["opp"] = {
                "type": opportunity.get("type"),
                "buy_yes": opportunity.get("buy_yes"),
                "buy_no": opportunity.get("buy_no"),
                "size": opportunity.get("size"),
                "expected_profit": opportunity.get("expected_profit"),
            }
        else:
            snap["opp"] = None

        self._buffer.append(snap)
        self._snap_count += 1

        # Flush to disk periodically
        now = time.time()
        if now - self._last_flush >= self._flush_interval:
            self.flush()

    def flush(self):
        """Write buffered snapshots to disk."""
        if not self.enabled or not self._buffer:
            return

        try:
            with open(self._filepath, "a") as f:
                for snap in self._buffer:
                    f.write(json.dumps(snap) + "\n")
            self._buffer = []
            self._last_flush = time.time()
        except Exception as e:
            print(f"[!] Data collector flush error: {e}")

    def get_stats(self):
        """Return collection stats for the web UI."""
        file_size = 0
        if self.enabled and os.path.exists(self._filepath):
            file_size = os.path.getsize(self._filepath)

        return {
            "enabled": self.enabled,
            "snapshots_recorded": self._snap_count,
            "buffer_size": len(self._buffer),
            "file": self._filepath if self.enabled else None,
            "file_size_kb": round(file_size / 1024, 1),
        }

    def get_session_file(self):
        """Return the current session file path."""
        return self._filepath if self.enabled else None


def list_snapshot_files():
    """List all snapshot session files available for backtesting."""
    if not os.path.exists(SNAPSHOT_DIR):
        return []
    files = []
    for f in sorted(os.listdir(SNAPSHOT_DIR)):
        if f.endswith(".jsonl"):
            path = os.path.join(SNAPSHOT_DIR, f)
            size = os.path.getsize(path)
            # Count lines
            with open(path, "r") as fh:
                lines = sum(1 for _ in fh)
            files.append({
                "filename": f,
                "path": path,
                "size_kb": round(size / 1024, 1),
                "snapshots": lines,
            })
    return files


def load_snapshots(filepath):
    """Load all snapshots from a JSONL file."""
    snapshots = []
    with open(filepath, "r") as f:
        for line in f:
            line = line.strip()
            if line:
                snapshots.append(json.loads(line))
    return snapshots


--- FILE: src/execution.py ---
import time
from src.records import log_decision

CLOB_HOST = "https://clob.polymarket.com"


class ExecutionEngine:
    def __init__(self, config, risk_guard, market_client=None):
        self.config = config
        self.risk = risk_guard
        self.mode = config["MODE"]
        self.client = None
        self.paper_engine = None

        # Initialize paper trading engine for PAPER mode
        if self.mode == "PAPER":
            from src.paper_engine import PaperTradingEngine
            self.paper_engine = PaperTradingEngine(config, market_client)

        # Initialize trading client only for LIVE mode (requires L2 auth)
        if self.mode == "LIVE":
            from py_clob_client.client import ClobClient
            from py_clob_client.clob_types import ApiCreds
            from py_clob_client.constants import POLYGON

            creds = ApiCreds(
                api_key=config["POLY_API_KEY"],
                api_secret=config["POLY_SECRET"],
                api_passphrase=config["POLY_PASSPHRASE"],
            )
            self.client = ClobClient(
                CLOB_HOST,
                key=config.get("POLY_PRIVATE_KEY", ""),
                chain_id=POLYGON,
                creds=creds,
            )

    def execute_plan(self, plan, book=None, market_info=None):
        # PAPER mode: route to paper trading engine
        if self.mode == "PAPER" and self.paper_engine:
            result = self.paper_engine.execute_paper_trade(plan, book, market_info or {})
            if result.get("success"):
                print(f"[PAPER] Filled: YES@{result['yes_price']:.3f} + "
                      f"NO@{result['no_price']:.3f} x{result['size']} "
                      f"profit=${result['expected_profit']:.4f}")
            return result

        if self.mode != "LIVE":
            print(f"[{self.mode}] Would execute: {plan}")
            return

        # 1. Re-check Risk (Spec 9.3)
        if not self.risk.can_trade(plan):
            print("[!] Trade rejected by Risk Guard")
            log_decision("REJECTED", "Risk Guard blocked trade")
            return

        print(f"[EXEC] Placing Orders: YES @ {plan['buy_yes']}, NO @ {plan['buy_no']}")

        # Spec 9.2: Place both legs as limit orders
        yes_order_id = self._place_order(
            plan["yes_token_id"], "BUY", plan["buy_yes"], plan["size"]
        )
        no_order_id = self._place_order(
            plan["no_token_id"], "BUY", plan["buy_no"], plan["size"]
        )

        if not yes_order_id and not no_order_id:
            log_decision("FAILED", "Both orders failed to place")
            return

        self.monitor_fills(plan, yes_order_id, no_order_id)

    def _place_order(self, token_id, side, price, size):
        """Place a single limit order. Returns order ID or None."""
        from py_clob_client.clob_types import OrderArgs, OrderType
        from py_clob_client.order_builder.constants import BUY, SELL

        order_side = BUY if side == "BUY" else SELL

        try:
            order_args = OrderArgs(
                price=price,
                size=size,
                side=order_side,
                token_id=token_id,
            )
            signed_order = self.client.create_order(order_args)
            resp = self.client.post_order(signed_order, OrderType.GTC)

            if resp.get("success"):
                order_id = resp.get("orderID")
                print(f"[EXEC] Order placed: {order_id}")
                return order_id
            else:
                print(f"[!] Order failed: {resp.get('errorMsg', 'Unknown error')}")
                return None
        except Exception as e:
            print(f"[!] Order placement error: {e}")
            return None

    def monitor_fills(self, plan, yes_order_id, no_order_id):
        """Spec 9.2: Two-Leg fill policy — hedge if one leg fails."""
        if not yes_order_id and not no_order_id:
            return

        # If only one order was placed, cancel/hedge immediately
        if not yes_order_id or not no_order_id:
            placed_id = yes_order_id or no_order_id
            filled_side = "YES" if yes_order_id else "NO"
            self._cancel_and_hedge(placed_id, plan, filled_side=filled_side)
            return

        # Poll for fills (check every 0.5s, up to 10s)
        max_checks = 20
        for i in range(max_checks):
            time.sleep(0.5)

            try:
                yes_order = self.client.get_order(yes_order_id)
                no_order = self.client.get_order(no_order_id)
            except Exception as e:
                print(f"[!] Error checking order status: {e}")
                continue

            yes_matched = float(yes_order.get("size_matched", "0"))
            no_matched = float(no_order.get("size_matched", "0"))

            # Both fully filled — locked profit achieved
            if yes_matched >= plan["size"] and no_matched >= plan["size"]:
                profit = plan["expected_profit"] * plan["size"]
                log_decision("FILLED", f"Both legs filled. Locked profit: ${profit:.4f}")
                self.risk.current_exposure += (plan["buy_yes"] + plan["buy_no"]) * plan["size"]
                print(f"[EXEC] Both legs filled! Locked profit: ${profit:.4f}")
                return

            # After 5 seconds, check for stalled legs
            if i >= 10:
                yes_filled = yes_matched >= plan["size"]
                no_filled = no_matched >= plan["size"]

                if yes_filled and not no_filled:
                    print("[!] YES filled but NO stalled — canceling and hedging")
                    self._cancel_and_hedge(no_order_id, plan, filled_side="YES")
                    return
                elif no_filled and not yes_filled:
                    print("[!] NO filled but YES stalled — canceling and hedging")
                    self._cancel_and_hedge(yes_order_id, plan, filled_side="NO")
                    return

        # Timeout: cancel both unfilled orders
        print("[!] Fill timeout — canceling remaining orders")
        self._cancel_order(yes_order_id)
        self._cancel_order(no_order_id)
        log_decision("TIMEOUT", "Fill monitoring timeout, orders cancelled")

    def _cancel_order(self, order_id):
        """Cancel a single order."""
        if not order_id:
            return
        try:
            self.client.cancel(order_id)
            print(f"[EXEC] Cancelled order: {order_id}")
        except Exception as e:
            print(f"[!] Cancel error for {order_id}: {e}")

    def _cancel_and_hedge(self, unfilled_order_id, plan, filled_side=None):
        """Spec 9.2: Cancel unfilled order and hedge the filled side."""
        self._cancel_order(unfilled_order_id)

        if not filled_side:
            log_decision("HEDGE", "One leg failed to place, cancelled remaining")
            return

        # Hedge: sell the filled position back at current best bid
        if filled_side == "YES":
            hedge_token = plan["yes_token_id"]
        else:
            hedge_token = plan["no_token_id"]

        try:
            book = self.client.get_order_book(hedge_token)
            if book.bids:
                hedge_price = float(book.bids[0].price)
                self._place_order(hedge_token, "SELL", hedge_price, plan["size"])
                log_decision("HEDGE", f"Sold {filled_side} side at {hedge_price} to hedge")
                print(f"[EXEC] Hedge order placed for {filled_side} side at {hedge_price}")
            else:
                log_decision("HEDGE_FAILED", f"No bids available to hedge {filled_side} side")
                print(f"[!] No bids available to hedge {filled_side} side")
        except Exception as e:
            log_decision("HEDGE_FAILED", f"Hedge error: {e}")
            print(f"[!] Hedge error: {e}")


--- FILE: src/health.py ---
import time

_last_report = 0
_REPORT_INTERVAL = 10  # Print status every 10 seconds


def report_status(bot):
    global _last_report
    now = time.time()
    if now - _last_report < _REPORT_INTERVAL:
        return
    _last_report = now

    uptime = int(now - bot._start_time)
    mins, secs = divmod(uptime, 60)
    hours, mins = divmod(mins, 60)

    total = len(bot._current_markets)
    offset = bot._market_offset
    pct = round(offset / max(total, 1) * 100)
    hot_count = sum(1 for v in bot._market_heat.values() if v < 0.01)

    lb_wallets = len(bot.whale_tracker.tracked_wallets)
    net_wallets = len(bot.whale_tracker.network_wallets)
    copies = bot._copy_trades

    parts = [
        f"cycle={bot._cycle_count}",
        f"markets={total}",
        f"rotation={pct}%",
        f"hot={hot_count}",
        f"track={lb_wallets}+{net_wallets}",
        f"copies={copies}/{bot._copy_exits}",
        f"up={hours}h{mins:02d}m",
    ]

    if bot.execution.paper_engine:
        summary = bot.execution.paper_engine.get_portfolio_summary()
        parts.append(f"bal=${summary['cash_balance']:.2f}")
        parts.append(f"trades={summary['total_trades']}")
        rpnl = summary['realized_pnl']
        sign = "+" if rpnl >= 0 else ""
        parts.append(f"real={sign}${rpnl:.2f}")

    # Scorer stats
    if hasattr(bot, 'wallet_scorer'):
        ss = bot.wallet_scorer.get_summary()
        scored = ss.get("scored_wallets", 0)
        hot = ss.get("hot_wallets", 0)
        cut = ss.get("cutoff_wallets", 0)
        if scored > 0:
            parts.append(f"scored={scored}/hot={hot}/cut={cut}")

    print(f"[STATUS] {' | '.join(parts)}")


--- FILE: src/infra_tiers.py ---
"""Infrastructure tier definitions for paper trading simulation.

Models the real-world cost and performance impact of different
server setups on a Polymarket arbitrage bot.
"""

import random

# ── TIER DEFINITIONS ─────────────────────────────────────────
# Each tier models: monthly cost, execution quality, and reliability.
#
# slippage_mult:  Multiplier on simulated slippage (1.0 = baseline)
# fill_rate:      Probability a valid opportunity actually fills (0-1)
# uptime:         Fraction of time the bot is actually running (0-1)
# scan_speed:     Markets scanned per cycle (more = more chances)
# monthly_cost:   USD deducted from paper balance each month

TIERS = {
    1: {
        "name": "Local Machine",
        "tag": "FREE",
        "description": "Your laptop. Free but unreliable — sleeps, restarts, home internet latency.",
        "monthly_cost": 0.0,
        "slippage_mult": 2.0,
        "fill_rate": 0.80,
        "uptime": 0.90,
        "scan_speed": 5,
        "latency_ms": 120,
    },
    2: {
        "name": "Basic Cloud VPS",
        "tag": "$12/mo",
        "description": "DigitalOcean/Vultr basic droplet. 24/7 uptime, decent latency.",
        "monthly_cost": 12.0,
        "slippage_mult": 1.4,
        "fill_rate": 0.90,
        "uptime": 0.99,
        "scan_speed": 5,
        "latency_ms": 45,
    },
    3: {
        "name": "Performance Cloud",
        "tag": "$48/mo",
        "description": "Dedicated vCPUs, NVMe, low-latency region. Serious setup.",
        "monthly_cost": 48.0,
        "slippage_mult": 1.1,
        "fill_rate": 0.96,
        "uptime": 0.999,
        "scan_speed": 10,
        "latency_ms": 12,
    },
    4: {
        "name": "Co-located Premium",
        "tag": "$150/mo",
        "description": "Bare-metal near exchange infrastructure. Minimal latency, max fill rate.",
        "monthly_cost": 150.0,
        "slippage_mult": 1.0,
        "fill_rate": 0.99,
        "uptime": 0.9999,
        "scan_speed": 15,
        "latency_ms": 2,
    },
}


def get_tier(tier_id):
    """Get tier config by ID. Defaults to tier 1 (free)."""
    return TIERS.get(tier_id, TIERS[1])


def get_all_tiers():
    """Return all tier definitions for the UI."""
    return {k: dict(v) for k, v in TIERS.items()}


# ── SIMULATION EFFECTS ───────────────────────────────────────

def apply_uptime_check(tier):
    """Simulate whether the bot is 'online' this cycle.
    Returns True if the bot is up, False if simulating downtime."""
    return random.random() < tier["uptime"]


def apply_fill_rate(tier):
    """Simulate whether a valid opportunity actually gets filled.
    Lower tiers miss more opportunities due to latency."""
    return random.random() < tier["fill_rate"]


def apply_slippage(base_slippage, tier):
    """Scale slippage based on infrastructure quality."""
    return base_slippage * tier["slippage_mult"]


def calculate_daily_infra_cost(tier):
    """Convert monthly cost to daily rate."""
    return tier["monthly_cost"] / 30.0


def calculate_hourly_infra_cost(tier):
    """Convert monthly cost to hourly rate (for per-cycle deduction)."""
    return tier["monthly_cost"] / (30.0 * 24.0)


def tier_comparison_table(total_profit, days_running):
    """Generate a comparison of how each tier would have performed.
    Useful for the UI to show 'what-if' across all tiers."""
    results = []
    for tid, tier in TIERS.items():
        infra_cost = tier["monthly_cost"] * (days_running / 30.0)
        # Scale profit by fill_rate and uptime relative to the best tier
        best = TIERS[4]
        relative_efficiency = (tier["fill_rate"] * tier["uptime"]) / (best["fill_rate"] * best["uptime"])
        estimated_gross = total_profit * relative_efficiency
        net = estimated_gross - infra_cost

        results.append({
            "tier_id": tid,
            "name": tier["name"],
            "tag": tier["tag"],
            "monthly_cost": tier["monthly_cost"],
            "total_infra_cost": round(infra_cost, 2),
            "estimated_gross_profit": round(estimated_gross, 2),
            "estimated_net_profit": round(net, 2),
            "fill_rate": tier["fill_rate"],
            "uptime": tier["uptime"],
            "latency_ms": tier["latency_ms"],
            "roi_positive": net > 0,
        })
    return results


--- FILE: src/market.py ---
from py_clob_client.client import ClobClient
from py_clob_client.clob_types import BookParams

CLOB_HOST = "https://clob.polymarket.com"


class MarketDataService:
    def __init__(self, config):
        self.config = config
        # L0 client: no auth needed for reading markets and order books
        self.client = ClobClient(CLOB_HOST)

    def get_active_markets(self):
        """Spec 6.2: Pulls active markets (YES/NO only).
        Uses get_sampling_simplified_markets for pre-filtered active markets."""
        all_markets = []

        try:
            resp = self.client.get_sampling_simplified_markets()
            data = resp if isinstance(resp, list) else resp.get("data", [])
        except Exception as e:
            print(f"[!] Error fetching sampling markets: {e}")
            # Fallback to paginated scan
            return self._get_active_markets_fallback()

        for m in data:
            if not m.get("active", False):
                continue
            if not m.get("accepting_orders", False):
                continue
            if m.get("closed", False) or m.get("archived", False):
                continue

            tokens = m.get("tokens", [])
            if len(tokens) != 2:
                continue

            yes_token = None
            no_token = None
            for t in tokens:
                outcome = t.get("outcome", "").lower()
                if outcome == "yes":
                    yes_token = t
                elif outcome == "no":
                    no_token = t

            if yes_token and no_token:
                all_markets.append({
                    "condition_id": m["condition_id"],
                    "yes_token_id": yes_token["token_id"],
                    "no_token_id": no_token["token_id"],
                    "yes_price": yes_token.get("price", 0),
                    "no_price": no_token.get("price", 0),
                })

        return all_markets

    def _get_active_markets_fallback(self):
        """Fallback: paginate get_simplified_markets if sampling endpoint fails."""
        all_markets = []
        next_cursor = "MA=="
        max_pages = 15

        for _ in range(max_pages):
            try:
                resp = self.client.get_simplified_markets(next_cursor=next_cursor)
            except Exception as e:
                print(f"[!] Error fetching markets: {e}")
                break

            for m in resp.get("data", []):
                if not m.get("active", False):
                    continue
                if not m.get("accepting_orders", False):
                    continue
                if m.get("closed", False) or m.get("archived", False):
                    continue

                tokens = m.get("tokens", [])
                if len(tokens) != 2:
                    continue

                yes_token = None
                no_token = None
                for t in tokens:
                    outcome = t.get("outcome", "").lower()
                    if outcome == "yes":
                        yes_token = t
                    elif outcome == "no":
                        no_token = t

                if yes_token and no_token:
                    all_markets.append({
                        "condition_id": m["condition_id"],
                        "yes_token_id": yes_token["token_id"],
                        "no_token_id": no_token["token_id"],
                        "yes_price": yes_token.get("price", 0),
                        "no_price": no_token.get("price", 0),
                    })

            next_cursor = resp.get("next_cursor", "LTE=")
            if next_cursor == "LTE=":
                break

        return all_markets

    def get_order_book(self, market, client=None):
        """Fetch live order book depth for both YES and NO sides.

        Pass client= for thread-safe parallel use (each thread
        should create its own ClobClient to avoid shared session issues).
        """
        if not market:
            return None

        yes_id = market.get("yes_token_id")
        no_id = market.get("no_token_id")

        if not yes_id or not no_id:
            return None

        c = client or self.client

        try:
            yes_book = c.get_order_book(yes_id)
            no_book = c.get_order_book(no_id)
        except Exception:
            return None

        # Transform to format expected by strategy.py: [[price, size], ...]
        asks_yes = [[ask.price, ask.size] for ask in yes_book.asks] if yes_book.asks else []
        asks_no = [[ask.price, ask.size] for ask in no_book.asks] if no_book.asks else []
        bids_yes = [[bid.price, bid.size] for bid in yes_book.bids] if yes_book.bids else []
        bids_no = [[bid.price, bid.size] for bid in no_book.bids] if no_book.bids else []

        if not asks_yes or not asks_no:
            return None

        return {
            "condition_id": market["condition_id"],
            "yes_token_id": yes_id,
            "no_token_id": no_id,
            "asks_yes": asks_yes,
            "asks_no": asks_no,
            "bids_yes": bids_yes,
            "bids_no": bids_no,
        }

    # ── Book Health Check (Defensive Execution) ──────────────
    #
    # Polymarket 15-min binary markets move fast: the winning side hits
    # $0.99 within minutes. The whale enters at $0.50-$0.55 and by the
    # time we poll, the book shows $0.99 asks even on LIVE markets.
    #
    # Old approach (spread check) blocked EVERYTHING — zero trades in 11h.
    #
    # New approach for paper mode: only block RESOLVED markets (API 404).
    # For live markets, the 12-layer stress simulator handles slippage,
    # rejection, and fill probability realistically.

    def check_book_health(self, token_id):
        """Check if a market's order book still exists (not resolved).

        A 404 means the market resolved and no book exists — block trade.
        Any valid book response means the market is live — allow trade.
        Non-404 errors (network/rate limit): fail-open for paper mode.
        """
        try:
            self.client.get_order_book(token_id)
        except Exception as e:
            err_str = str(e)
            if "404" in err_str or "No orderbook" in err_str:
                return {"healthy": False,
                        "reason": "Market resolved (no orderbook)"}
            return {"healthy": True, "reason": "API error, proceeding"}

        return {"healthy": True, "reason": "Book exists"}


--- FILE: src/paper_engine.py ---
"""Core paper trading engine with thread-safe state and JSON persistence."""

import threading
import json
import time
import os
import uuid

from src.paper_fees import calculate_trading_fee, calculate_withdrawal_haircut
from src.paper_fills import simulate_two_leg_fill
from src.records import log_decision
from src.stress_sim import StressSimulator

STATE_FILE = "data/paper_state.json"
SNAPSHOT_INTERVAL = 60  # seconds between PnL snapshots
MAX_TRADE_HISTORY = 1000
MAX_SNAPSHOTS = 10000
DEFAULT_FEE_BPS = 200               # Conservative 2% fee when API returns 0


class PaperTradingEngine:
    """Thread-safe paper trading engine with persistent state."""

    def __init__(self, config, market_client=None, wallet_scorer=None):
        self._lock = threading.RLock()
        self.config = config
        self.market_client = market_client  # L0 ClobClient for fee lookups
        self.scorer = wallet_scorer
        self.starting_balance = config.get("PAPER_BALANCE", 1000.0)
        self._last_snapshot_time = 0
        self._hedge_blocks = 0  # Counter for anti-hedge blocks
        self.stress = StressSimulator()  # Comprehensive friction simulation
        self._load_or_create_state()

    # ── State Persistence ────────────────────────────────────────

    def _load_or_create_state(self):
        os.makedirs(os.path.dirname(STATE_FILE), exist_ok=True)

        if os.path.exists(STATE_FILE):
            try:
                with open(STATE_FILE, "r") as f:
                    state = json.load(f)
                self.portfolio = state
                print(f"[PAPER] Loaded state: balance=${state['cash_balance']:.2f}, "
                      f"{len(state.get('positions', {}))} positions, "
                      f"{state.get('total_trades', 0)} trades")
                return
            except Exception as e:
                print(f"[!] Error loading paper state, creating fresh: {e}")

        self.portfolio = {
            "version": 3,
            "starting_balance": self.starting_balance,
            "cash_balance": self.starting_balance,
            "total_trades": 0,
            "winning_trades": 0,
            "losing_trades": 0,
            "total_fees_paid": 0.0,
            "total_realized_pnl": 0.0,
            "total_opportunities_seen": 0,
            "total_scans": 0,
            "created_at": time.time(),
            "last_updated": time.time(),
            "positions": {},
            "trade_history": [],
            "pnl_snapshots": [],
        }
        self._save_state()
        print(f"[PAPER] New portfolio: starting balance=${self.starting_balance:.2f}")

    def _save_state(self):
        self.portfolio["last_updated"] = time.time()
        try:
            with open(STATE_FILE, "w") as f:
                json.dump(self.portfolio, f, indent=2)
        except Exception as e:
            print(f"[!] Error saving paper state: {e}")

    # ── Core Trading ─────────────────────────────────────────────

    def execute_paper_trade(self, plan, book, market_info):
        """Execute a paper trade using live order book for fill simulation."""
        with self._lock:
            if not book or not plan:
                return {"success": False, "reason": "Missing book or plan"}

            condition_id = plan.get("condition_id", "")
            yes_token = plan.get("yes_token_id", "")
            no_token = plan.get("no_token_id", "")
            size = plan.get("size", 10.0)

            self.portfolio["total_opportunities_seen"] = \
                self.portfolio.get("total_opportunities_seen", 0) + 1

            # Look up fee rates
            yes_fee_bps = self._get_fee_rate(yes_token)
            no_fee_bps = self._get_fee_rate(no_token)

            # Simulate fills against live order book
            result = simulate_two_leg_fill(
                book.get("asks_yes", []),
                book.get("asks_no", []),
                size,
                yes_fee_bps,
                no_fee_bps,
            )

            if not result["both_filled"]:
                log_decision("PAPER_SKIP", f"Insufficient liquidity for {condition_id[:12]}")
                return {"success": False, "reason": "Insufficient liquidity"}

            total_cost = result["total_cost"]

            # Check balance
            if total_cost > self.portfolio["cash_balance"]:
                log_decision("PAPER_SKIP", f"Insufficient balance: need ${total_cost:.2f}")
                return {"success": False, "reason": "Insufficient balance"}

            # Deduct cost
            self.portfolio["cash_balance"] -= total_cost
            self.portfolio["total_fees_paid"] += result["yes_fee"] + result["no_fee"]

            # Record fills
            now = time.time()
            market_name = market_info.get("condition_id", condition_id)[:30]

            yes_fill_entry = {
                "fill_id": str(uuid.uuid4())[:8],
                "timestamp": now,
                "condition_id": condition_id,
                "market_name": market_name,
                "token_id": yes_token,
                "side": "YES",
                "direction": "BUY",
                "price": result["yes_fill"]["fill_price"],
                "size": result["yes_fill"]["fill_size"],
                "fee": result["yes_fee"],
                "slippage": result["yes_fill"]["slippage"],
                "fee_rate_bps": yes_fee_bps,
            }

            no_fill_entry = {
                "fill_id": str(uuid.uuid4())[:8],
                "timestamp": now,
                "condition_id": condition_id,
                "market_name": market_name,
                "token_id": no_token,
                "side": "NO",
                "direction": "BUY",
                "price": result["no_fill"]["fill_price"],
                "size": result["no_fill"]["fill_size"],
                "fee": result["no_fee"],
                "slippage": result["no_fill"]["slippage"],
                "fee_rate_bps": no_fee_bps,
            }

            self.portfolio["trade_history"].append(yes_fill_entry)
            self.portfolio["trade_history"].append(no_fill_entry)

            # Trim history
            if len(self.portfolio["trade_history"]) > MAX_TRADE_HISTORY:
                self.portfolio["trade_history"] = self.portfolio["trade_history"][-MAX_TRADE_HISTORY:]

            self.portfolio["total_trades"] += 1

            # Create or update position
            pos = self.portfolio["positions"].get(condition_id)
            if pos:
                # Average in
                old_yes_cost = pos["yes_avg_price"] * pos["yes_size"]
                old_no_cost = pos["no_avg_price"] * pos["no_size"]
                pos["yes_size"] += result["yes_fill"]["fill_size"]
                pos["no_size"] += result["no_fill"]["fill_size"]
                new_yes_cost = old_yes_cost + result["yes_fill"]["fill_price"] * result["yes_fill"]["fill_size"]
                new_no_cost = old_no_cost + result["no_fill"]["fill_price"] * result["no_fill"]["fill_size"]
                pos["yes_avg_price"] = new_yes_cost / pos["yes_size"] if pos["yes_size"] > 0 else 0
                pos["no_avg_price"] = new_no_cost / pos["no_size"] if pos["no_size"] > 0 else 0
                pos["total_cost"] += total_cost
                pos["total_fees"] += result["yes_fee"] + result["no_fee"]
            else:
                self.portfolio["positions"][condition_id] = {
                    "position_id": str(uuid.uuid4())[:8],
                    "condition_id": condition_id,
                    "market_name": market_name,
                    "yes_token_id": yes_token,
                    "no_token_id": no_token,
                    "yes_size": result["yes_fill"]["fill_size"],
                    "no_size": result["no_fill"]["fill_size"],
                    "yes_avg_price": result["yes_fill"]["fill_price"],
                    "no_avg_price": result["no_fill"]["fill_price"],
                    "total_cost": total_cost,
                    "total_fees": result["yes_fee"] + result["no_fee"],
                    "opened_at": now,
                    "status": "OPEN",
                    "settlement_value": 0.0,
                }

            self._save_state()

            profit_str = f"${result['expected_profit']:.4f}"
            log_decision("PAPER_FILL",
                         f"Bought YES@{result['yes_fill']['fill_price']:.3f} + "
                         f"NO@{result['no_fill']['fill_price']:.3f} x{result['matched_size']} "
                         f"profit={profit_str} fees=${result['yes_fee']+result['no_fee']:.4f}")

            return {
                "success": True,
                "total_cost": total_cost,
                "expected_profit": result["expected_profit"],
                "yes_price": result["yes_fill"]["fill_price"],
                "no_price": result["no_fill"]["fill_price"],
                "size": result["matched_size"],
                "fees": result["yes_fee"] + result["no_fee"],
            }

    def execute_copy_trade(self, signal, current_exposure=0.0):
        """Execute a single-side copy trade (directional, not arb).

        Buys one side (YES or NO) based on what the whale bought.
        Profit/loss depends on market outcome at settlement.
        Signal score controls copy size (higher score = bigger bet).
        """
        with self._lock:
            condition_id = signal.get("condition_id", "")
            token_id = signal.get("token_id", "")
            outcome = signal.get("outcome", "YES").upper()
            whale_price = signal.get("whale_price", 0)
            market_title = signal.get("market_title", "")[:40]
            score = signal.get("score", 1)

            if whale_price <= 0 or whale_price >= 1.0:
                return {"success": False, "reason": "Invalid price"}

            # ── Anti-hedge: don't bet opposite side of same market ──
            if self.scorer:
                safe = self.scorer.check_anti_hedge(
                    condition_id, outcome, self.portfolio["positions"]
                )
                if not safe:
                    self._hedge_blocks += 1
                    return {"success": False, "reason": "Anti-hedge: opposite side open"}

            # ── Wallet performance multiplier ──
            # Proven winners get bigger copies, proven losers get cut
            wallet_mult = 1.0
            source_wallet = signal.get("source_wallet", "")
            if self.scorer and source_wallet:
                wallet_mult = self.scorer.get_wallet_multiplier(source_wallet)
                if wallet_mult <= 0.0:
                    return {"success": False, "reason": "Wallet cut off (proven loser)"}

            # ── Dynamic percentage-based risk ──
            # All limits scale with current balance. As account grows,
            # risk percentages increase progressively (compound growth).
            balance = self.portfolio["cash_balance"]
            growth = balance / max(self.starting_balance, 1)

            # Progressive growth multiplier: risk more as account grows
            if growth >= 3.0:
                growth_mult = 2.0     # 3x+ growth: double risk %
            elif growth >= 2.0:
                growth_mult = 1.5     # 2x growth: 50% more risk %
            elif growth >= 1.5:
                growth_mult = 1.25    # 50% growth: 25% more risk %
            else:
                growth_mult = 1.0     # Still building

            # Calculate dynamic limits from balance percentages
            exposure_pct = self.config.get("RISK_MAX_EXPOSURE_PCT", 0.50)
            market_pct = self.config.get("RISK_MAX_MARKET_PCT", 0.06)
            min_trade_pct = self.config.get("RISK_PER_TRADE_PCT", 0.01)
            max_trade_pct = self.config.get("RISK_MAX_TRADE_PCT", 0.03)

            max_exposure = balance * exposure_pct * growth_mult
            max_per_market = balance * market_pct * growth_mult
            copy_min = max(0.25, balance * min_trade_pct * growth_mult)
            copy_max = max(0.50, balance * max_trade_pct * growth_mult)

            # ── Exposure guard ──
            if current_exposure >= max_exposure:
                return {"success": False, "reason": f"Max exposure ${max_exposure:.2f} reached"}

            # ── Position concentration limit ──
            existing_cost = 0.0
            for pk, pos in self.portfolio["positions"].items():
                if pos["status"] == "OPEN" and pos.get("condition_id") == condition_id:
                    existing_cost += pos.get("total_cost", 0)
            if existing_cost >= max_per_market:
                return {"success": False, "reason": "Market concentration limit"}

            # ── Book stability / liquidity check ──
            if self.market_client and token_id:
                book_health = self.market_client.check_book_health(token_id)
                if not book_health.get("healthy", True):
                    return {"success": False,
                            "reason": f"Book: {book_health.get('reason', 'unhealthy')}"}

            # ── Score-based proportional sizing ──
            # Base: 1% of whale's trade. Score multiplier scales it.
            whale_usdc = signal.get("usdc_value", 0)
            copy_ratio = self.config.get("COPY_RATIO", 0.01)
            score_multiplier = 1.0 + min(score - 1, 4) * 0.25  # 1.0x to 2.0x

            if whale_usdc > 0:
                copy_budget = whale_usdc * copy_ratio * score_multiplier * wallet_mult
                copy_budget = max(copy_min, min(copy_budget, copy_max))
            else:
                copy_budget = copy_min

            # Don't exceed remaining exposure room
            room = max_exposure - current_exposure
            if copy_budget > room:
                copy_budget = room
            if copy_budget < copy_min:
                return {"success": False, "reason": "Not enough exposure room"}

            # Don't exceed market concentration limit
            market_room = max_per_market - existing_cost
            if copy_budget > market_room:
                copy_budget = market_room
            if copy_budget < copy_min:
                return {"success": False, "reason": "Market limit reached"}

            # ── STRESS: Full Polymarket friction simulation ──
            # Covers: fill rejection, partial fills, variable slippage,
            # timing drift, signal staleness, copy crowd, book depletion,
            # rate limiting, API failures, spread widening, off-hours penalty
            signal_age = time.time() - signal.get("detected_at", time.time())
            stress_result = self.stress.stress_entry(
                whale_price=whale_price,
                copy_budget=copy_budget,
                condition_id=condition_id,
                signal_score=score,
                signal_age_sec=signal_age,
                min_size=copy_min,
            )

            if not stress_result["success"]:
                return {"success": False, "reason": stress_result["reason"]}

            our_price = stress_result["adjusted_price"]
            copy_budget = stress_result["adjusted_budget"]
            gas_fee = stress_result["gas_fee"]
            stress_tags = stress_result["stress_tags"]
            shares = copy_budget / our_price

            # Fee lookup
            fee_bps = self._get_fee_rate(token_id)
            fee = copy_budget * fee_bps / 10000
            total_cost = copy_budget + fee + gas_fee

            # Balance check
            if total_cost > self.portfolio["cash_balance"]:
                return {"success": False, "reason": "Insufficient balance"}

            # Deduct
            self.portfolio["cash_balance"] -= total_cost
            self.portfolio["total_fees_paid"] += fee + gas_fee
            self.portfolio["total_trades"] += 1

            # Record fill
            now = time.time()
            fill_entry = {
                "fill_id": str(uuid.uuid4())[:8],
                "timestamp": now,
                "condition_id": condition_id,
                "market_name": market_title,
                "token_id": token_id,
                "side": outcome,
                "direction": "BUY",
                "price": round(our_price, 4),
                "size": round(shares, 2),
                "fee": round(fee, 4),
                "fee_rate_bps": fee_bps,
                "slippage": round(our_price - whale_price, 4),
                "trade_type": "COPY",
                "source_username": signal.get("source_username", ""),
                "score": score,
            }

            self.portfolio["trade_history"].append(fill_entry)
            if len(self.portfolio["trade_history"]) > MAX_TRADE_HISTORY:
                self.portfolio["trade_history"] = self.portfolio["trade_history"][-MAX_TRADE_HISTORY:]

            # Position key: separate from arb positions
            pos_key = f"copy_{condition_id}_{outcome}"
            pos = self.portfolio["positions"].get(pos_key)

            if pos and pos.get("status") == "OPEN":
                # Stack onto existing OPEN position (average in)
                old_cost = pos.get("avg_price", 0) * pos.get("size", 0)
                pos["size"] = pos.get("size", 0) + shares
                new_cost = old_cost + our_price * shares
                pos["avg_price"] = round(new_cost / pos["size"], 4) if pos["size"] > 0 else 0
                pos["total_cost"] += total_cost
                pos["total_fees"] += fee
            else:
                self.portfolio["positions"][pos_key] = {
                    "position_id": str(uuid.uuid4())[:8],
                    "condition_id": condition_id,
                    "market_name": market_title,
                    "token_id": token_id,
                    "outcome": outcome,
                    "size": round(shares, 2),
                    "avg_price": round(our_price, 4),
                    "total_cost": round(total_cost, 4),
                    "total_fees": round(fee, 4),
                    "opened_at": now,
                    "status": "OPEN",
                    "settlement_value": 0.0,
                    "trade_type": "COPY",
                    "source_username": signal.get("source_username", ""),
                    "source_wallet": source_wallet,
                }

            self._save_state()

            # Record entry in wallet scorer for performance tracking
            if self.scorer and source_wallet:
                self.scorer.record_entry(source_wallet, condition_id,
                                         total_cost, market_title, score)

            slip_pct = stress_result["slippage_pct"]
            tags_str = " ".join(stress_tags)
            if tags_str:
                tags_str = " [" + tags_str + "]"
            log_decision("COPY_FILL",
                         f"Copied {signal.get('source_username', '?')}: "
                         f"BUY {outcome}@{our_price:.3f} x{shares:.1f} "
                         f"${total_cost:.2f} score={score} wm={wallet_mult:.1f} "
                         f"slip={slip_pct:.1f}% gas=${gas_fee:.3f}"
                         f"{tags_str} on \"{market_title}\"")

            return {
                "success": True,
                "total_cost": round(total_cost, 4),
                "price": round(our_price, 4),
                "size": round(shares, 2),
                "fees": round(fee, 4),
                "whale_price": whale_price,
                "slippage_pct": round((our_price - whale_price) / whale_price * 100, 2),
                "score": score,
                "score_multiplier": round(score_multiplier, 2),
            }

    def close_copy_position(self, signal, risk_guard=None):
        """Close a copy position when the whale exits.

        Simulates selling our shares at the whale's sell price minus slippage.
        Credits proceeds to cash balance and records realized PnL.
        """
        with self._lock:
            condition_id = signal.get("condition_id", "")
            outcome = signal.get("outcome", "").upper()
            whale_price = signal.get("whale_price", 0)
            market_title = signal.get("market_title", "")[:40]

            # Find matching open copy position
            pos_key = f"copy_{condition_id}_{outcome}"
            pos = self.portfolio["positions"].get(pos_key)

            if not pos or pos["status"] != "OPEN":
                return {"success": False, "reason": "No open position to close"}

            if pos.get("trade_type") != "COPY":
                return {"success": False, "reason": "Not a copy position"}

            # ── STRESS: Full friction on sell side ──
            signal_age = time.time() - signal.get("detected_at", time.time())
            exit_stress = self.stress.stress_exit(
                whale_price=whale_price,
                condition_id=condition_id,
                signal_age_sec=signal_age,
            )

            if not exit_stress["success"]:
                return {"success": False, "reason": exit_stress["reason"]}

            our_sell_price = exit_stress["adjusted_price"]
            gas_fee = exit_stress["gas_fee"]
            shares = pos["size"]
            gross_proceeds = shares * our_sell_price

            # Fee on the sell side
            fee_bps = self._get_fee_rate(pos.get("token_id", ""))
            fee = gross_proceeds * fee_bps / 10000
            net_proceeds = gross_proceeds - fee - gas_fee

            # Realized PnL
            realized_pnl = net_proceeds - pos["total_cost"]

            # Credit cash
            self.portfolio["cash_balance"] += net_proceeds
            self.portfolio["total_fees_paid"] += fee + gas_fee
            self.portfolio["total_realized_pnl"] += realized_pnl

            if realized_pnl >= 0:
                self.portfolio["winning_trades"] += 1
            else:
                self.portfolio["losing_trades"] += 1
                if risk_guard:
                    risk_guard.record_loss(abs(realized_pnl))

            if risk_guard:
                risk_guard.remove_exposure(pos["total_cost"])

            # Mark position closed
            close_time = time.time()
            pos["status"] = "CLOSED_EXIT"
            pos["closed_at"] = close_time
            pos["sell_price"] = round(our_sell_price, 4)
            pos["realized_pnl"] = round(realized_pnl, 4)
            pos["settlement_value"] = round(net_proceeds, 4)

            # Record result in wallet scorer
            if self.scorer and pos.get("source_wallet"):
                hold_time = close_time - pos.get("opened_at", close_time)
                self.scorer.record_result(
                    pos["source_wallet"], condition_id,
                    realized_pnl, hold_time, market_title
                )

            # Record the sell in trade history
            now = time.time()
            fill_entry = {
                "fill_id": str(uuid.uuid4())[:8],
                "timestamp": now,
                "condition_id": condition_id,
                "market_name": market_title,
                "token_id": pos.get("token_id", ""),
                "side": outcome,
                "direction": "SELL",
                "price": round(our_sell_price, 4),
                "size": round(shares, 2),
                "fee": round(fee, 4),
                "fee_rate_bps": fee_bps,
                "slippage": round(whale_price - our_sell_price, 4),
                "trade_type": "COPY_EXIT",
                "source_username": signal.get("source_username", ""),
                "realized_pnl": round(realized_pnl, 4),
            }
            self.portfolio["trade_history"].append(fill_entry)
            if len(self.portfolio["trade_history"]) > MAX_TRADE_HISTORY:
                self.portfolio["trade_history"] = self.portfolio["trade_history"][-MAX_TRADE_HISTORY:]

            self._save_state()

            pnl_label = f"+${realized_pnl:.4f}" if realized_pnl >= 0 else f"-${abs(realized_pnl):.4f}"
            log_decision("COPY_EXIT",
                         f"Exited with {signal.get('source_username', '?')}: "
                         f"SELL {outcome}@{our_sell_price:.3f} x{shares:.1f} "
                         f"PnL={pnl_label} on \"{market_title}\"")

            return {
                "success": True,
                "net_proceeds": round(net_proceeds, 4),
                "realized_pnl": round(realized_pnl, 4),
                "sell_price": round(our_sell_price, 4),
                "shares_sold": round(shares, 2),
                "fees": round(fee, 4),
            }

    def _get_fee_rate(self, token_id):
        """Get fee rate in bps for a token. Returns conservative default on failure."""
        if not self.market_client or not token_id:
            return DEFAULT_FEE_BPS  # Conservative fallback
        try:
            rate = self.market_client.get_fee_rate_bps(token_id)
            if rate <= 0:
                return DEFAULT_FEE_BPS  # API returned 0 — use conservative default
            return rate
        except Exception as e:
            log_decision("FEE_WARN", f"Fee lookup failed for {token_id[:12]}: {e}")
            return DEFAULT_FEE_BPS  # Conservative fallback

    # ── Auto Sell (Take-Profit / Stop-Loss) ─────────────────────

    def _auto_sell(self, pos, pos_key, current_price, reason, risk_guard=None):
        """Sell a copy position automatically (take-profit or stop-loss).

        Called during settlement checks when price target is hit.
        Uses stress simulation for realistic sell execution.
        """
        condition_id = pos.get("condition_id", "")
        outcome = pos.get("outcome", "")
        market_title = pos.get("market_name", "")

        # Stress on the sell
        exit_stress = self.stress.stress_exit(
            whale_price=current_price,
            condition_id=condition_id,
            signal_age_sec=0,
        )
        if not exit_stress["success"]:
            return  # Stress blocked the sell — try again next cycle

        our_sell_price = exit_stress["adjusted_price"]
        gas_fee = exit_stress["gas_fee"]
        shares = pos["size"]
        gross_proceeds = shares * our_sell_price

        fee_bps = self._get_fee_rate(pos.get("token_id", ""))
        fee = gross_proceeds * fee_bps / 10000
        net_proceeds = gross_proceeds - fee - gas_fee

        realized_pnl = net_proceeds - pos["total_cost"]

        # Credit cash
        self.portfolio["cash_balance"] += net_proceeds
        self.portfolio["total_fees_paid"] += fee + gas_fee
        self.portfolio["total_realized_pnl"] += realized_pnl

        if realized_pnl >= 0:
            self.portfolio["winning_trades"] += 1
        else:
            self.portfolio["losing_trades"] += 1
            if risk_guard:
                risk_guard.record_loss(abs(realized_pnl))

        if risk_guard:
            risk_guard.remove_exposure(pos["total_cost"])

        # Mark position
        close_time = time.time()
        pos["status"] = f"CLOSED_{reason}"
        pos["closed_at"] = close_time
        pos["sell_price"] = round(our_sell_price, 4)
        pos["realized_pnl"] = round(realized_pnl, 4)
        pos["settlement_value"] = round(net_proceeds, 4)

        # Scorer tracking
        if self.scorer and pos.get("source_wallet"):
            hold_time = close_time - pos.get("opened_at", close_time)
            self.scorer.record_result(
                pos["source_wallet"], condition_id,
                realized_pnl, hold_time, market_title
            )

        # Trade history
        fill_entry = {
            "fill_id": str(uuid.uuid4())[:8],
            "timestamp": close_time,
            "condition_id": condition_id,
            "market_name": market_title,
            "token_id": pos.get("token_id", ""),
            "side": outcome,
            "direction": "SELL",
            "price": round(our_sell_price, 4),
            "size": round(shares, 2),
            "fee": round(fee, 4),
            "fee_rate_bps": fee_bps,
            "trade_type": reason,
            "realized_pnl": round(realized_pnl, 4),
        }
        self.portfolio["trade_history"].append(fill_entry)
        if len(self.portfolio["trade_history"]) > MAX_TRADE_HISTORY:
            self.portfolio["trade_history"] = self.portfolio["trade_history"][-MAX_TRADE_HISTORY:]

        pnl_sign = "+" if realized_pnl >= 0 else ""
        pnl_pct = round((realized_pnl / pos["total_cost"]) * 100, 1) if pos["total_cost"] > 0 else 0
        log_decision(reason,
                     f"{outcome}@{our_sell_price:.3f} x{shares:.1f} "
                     f"PnL={pnl_sign}${realized_pnl:.2f} ({pnl_sign}{pnl_pct}%) "
                     f"on \"{market_title}\"")

    # ── Settlement ───────────────────────────────────────────────

    def check_and_settle_positions(self, market_service, risk_guard=None):
        """Check if any open positions' markets have resolved.
        Updates risk_guard exposure on settlement."""
        with self._lock:
            if not market_service:
                return

            for pos_key, pos in list(self.portfolio["positions"].items()):
                if pos["status"] != "OPEN":
                    continue

                condition_id = pos.get("condition_id", pos_key)
                is_copy = pos.get("trade_type") == "COPY"

                try:
                    market = market_service.client.get_market(condition_id)
                except Exception:
                    continue

                if not market:
                    continue

                # Check for resolution
                tokens = market.get("tokens", [])
                winner = None
                for t in tokens:
                    if t.get("winner", False):
                        outcome = t.get("outcome", "").upper()
                        winner = outcome
                        break

                if not winner:
                    # ── Take-profit / Stop-loss for unsettled copy positions ──
                    if is_copy:
                        our_outcome = pos.get("outcome", "").upper()
                        current_price = None
                        for t in tokens:
                            if t.get("outcome", "").upper() == our_outcome:
                                current_price = float(t.get("price", 0))
                                break

                        if current_price and current_price > 0 and pos.get("total_cost", 0) > 0:
                            sell_value = current_price * pos["size"]
                            pnl_pct = (sell_value - pos["total_cost"]) / pos["total_cost"]

                            tp_pct = self.config.get("TAKE_PROFIT_PCT", 0.15)
                            sl_pct = self.config.get("STOP_LOSS_PCT", 0.25)

                            if pnl_pct >= tp_pct:
                                self._auto_sell(pos, pos_key, current_price,
                                                "TAKE_PROFIT", risk_guard)
                            elif pnl_pct <= -sl_pct:
                                self._auto_sell(pos, pos_key, current_price,
                                                "STOP_LOSS", risk_guard)
                    continue

                # Settle based on position type
                if is_copy:
                    # Copy trade: single side — win if our outcome matches
                    our_outcome = pos.get("outcome", "").upper()
                    if winner == our_outcome:
                        payout = pos["size"] * 1.0
                    else:
                        payout = 0.0
                    pos["status"] = f"SETTLED_{winner}"
                else:
                    # Arb trade: both sides — winner side pays $1/share
                    if winner == "YES":
                        payout = pos["yes_size"] * 1.0
                    elif winner == "NO":
                        payout = pos["no_size"] * 1.0
                    else:
                        continue
                    pos["status"] = f"SETTLED_{winner}"

                pos["settlement_value"] = payout
                realized_pnl = payout - pos["total_cost"]
                self.portfolio["cash_balance"] += payout
                self.portfolio["total_realized_pnl"] += realized_pnl

                if realized_pnl >= 0:
                    self.portfolio["winning_trades"] += 1
                else:
                    self.portfolio["losing_trades"] += 1
                    if risk_guard:
                        risk_guard.record_loss(abs(realized_pnl))

                if risk_guard:
                    risk_guard.remove_exposure(pos["total_cost"])

                # Record result in wallet scorer for copy trades
                if is_copy and self.scorer and pos.get("source_wallet"):
                    settle_time = time.time()
                    hold_time = settle_time - pos.get("opened_at", settle_time)
                    self.scorer.record_result(
                        pos["source_wallet"], condition_id,
                        realized_pnl, hold_time,
                        pos.get("market_name", "")
                    )

                trade_type = "COPY" if is_copy else "ARB"
                log_decision("PAPER_SETTLED",
                             f"[{trade_type}] {condition_id[:12]} resolved {winner}. "
                             f"Payout=${payout:.2f} PnL=${realized_pnl:.4f}")

            self._save_state()

    # ── PnL Snapshots ────────────────────────────────────────────

    def record_pnl_snapshot(self, current_prices=None):
        """Record portfolio value snapshot (max once per minute)."""
        now = time.time()
        if now - self._last_snapshot_time < SNAPSHOT_INTERVAL:
            return

        with self._lock:
            self._last_snapshot_time = now

            unrealized = self._calculate_unrealized_pnl(current_prices)
            total_value = self.portfolio["cash_balance"] + unrealized

            snapshot = {
                "timestamp": now,
                "cash_balance": round(self.portfolio["cash_balance"], 2),
                "unrealized_pnl": round(unrealized, 2),
                "total_value": round(total_value, 2),
                "positions_count": len([p for p in self.portfolio["positions"].values()
                                        if p["status"] == "OPEN"]),
            }

            self.portfolio["pnl_snapshots"].append(snapshot)

            if len(self.portfolio["pnl_snapshots"]) > MAX_SNAPSHOTS:
                self.portfolio["pnl_snapshots"] = self.portfolio["pnl_snapshots"][-MAX_SNAPSHOTS:]

            self._save_state()

    def _calculate_unrealized_pnl(self, current_prices=None):
        """Estimate unrealized PnL from open positions."""
        unrealized = 0.0
        for cid, pos in self.portfolio["positions"].items():
            if pos["status"] != "OPEN":
                continue

            if pos.get("trade_type") == "COPY":
                # Copy trade: best case = size * $1 - cost (if our side wins)
                # Use 50% expected value as conservative estimate
                unrealized += (pos["size"] * 0.5) - pos["total_cost"]
            else:
                # Arb: deterministic — both sides settle to $1
                settlement = min(pos["yes_size"], pos["no_size"]) * 1.0
                unrealized += settlement - pos["total_cost"]
        return unrealized

    # ── Portfolio Queries (thread-safe, called by web UI) ────────

    def get_portfolio_summary(self):
        with self._lock:
            p = self.portfolio
            unrealized = self._calculate_unrealized_pnl()
            total_value = p["cash_balance"] + unrealized
            net_profit = total_value - p["starting_balance"]
            withdrawal_fee = calculate_withdrawal_haircut(net_profit)

            # ── Confidence Report ──
            # Pessimistic: all open copy positions lose (pay $0)
            # Optimistic: all open copy positions win (pay $1/share)
            # Realistic: use current 50% estimate (already in unrealized)
            pessimistic_unrealized = 0.0
            optimistic_unrealized = 0.0
            open_copy_count = 0
            open_arb_count = 0

            for cid, pos in p["positions"].items():
                if pos["status"] != "OPEN":
                    continue
                if pos.get("trade_type") == "COPY":
                    open_copy_count += 1
                    # Pessimistic: we lose everything
                    pessimistic_unrealized += 0.0 - pos["total_cost"]
                    # Optimistic: our side wins, payout = shares * $1
                    optimistic_unrealized += pos["size"] * 1.0 - pos["total_cost"]
                else:
                    open_arb_count += 1
                    # Arb is deterministic
                    arb_val = min(pos["yes_size"], pos["no_size"]) * 1.0 - pos["total_cost"]
                    pessimistic_unrealized += arb_val
                    optimistic_unrealized += arb_val

            pessimistic_total = p["cash_balance"] + pessimistic_unrealized
            optimistic_total = p["cash_balance"] + optimistic_unrealized

            return {
                "starting_balance": p["starting_balance"],
                "cash_balance": round(p["cash_balance"], 2),
                "unrealized_pnl": round(unrealized, 2),
                "realized_pnl": round(p["total_realized_pnl"], 2),
                "total_value": round(total_value, 2),
                "net_profit": round(net_profit, 2),
                "withdrawal_haircut": round(withdrawal_fee, 2),
                "net_after_haircut": round(net_profit - withdrawal_fee, 2),
                "total_trades": p["total_trades"],
                "winning_trades": p["winning_trades"],
                "losing_trades": p["losing_trades"],
                "win_rate": round(p["winning_trades"] / max(p["total_trades"], 1) * 100, 1),
                "total_fees_paid": round(p["total_fees_paid"], 4),
                "total_opportunities_seen": p.get("total_opportunities_seen", 0),
                "open_positions": len([pos for pos in p["positions"].values()
                                       if pos["status"] == "OPEN"]),
                "uptime_since": p["created_at"],
                # Confidence report
                "confidence": {
                    "pessimistic_value": round(pessimistic_total, 2),
                    "realistic_value": round(total_value, 2),
                    "optimistic_value": round(optimistic_total, 2),
                    "pessimistic_pnl": round(pessimistic_total - p["starting_balance"], 2),
                    "realistic_pnl": round(net_profit, 2),
                    "optimistic_pnl": round(optimistic_total - p["starting_balance"], 2),
                    "open_copy_positions": open_copy_count,
                    "open_arb_positions": open_arb_count,
                    "hedge_blocks": self._hedge_blocks,
                    "stress": self.stress.get_stats(),
                },
            }

    def get_positions(self):
        with self._lock:
            positions = []
            for pos_key, pos in self.portfolio["positions"].items():
                entry = dict(pos)
                is_copy = pos.get("trade_type") == "COPY"

                if pos["status"] == "OPEN":
                    if is_copy:
                        # Copy trade: unrealized depends on outcome (unknown)
                        # Show break-even estimate: if our side wins, profit = size - cost
                        entry["unrealized_pnl"] = round(pos["size"] * 1.0 - pos["total_cost"], 4)
                        entry["unrealized_label"] = "if_win"
                    else:
                        # Arb trade: deterministic (both sides settle to $1)
                        settlement = min(pos["yes_size"], pos["no_size"]) * 1.0
                        entry["unrealized_pnl"] = round(settlement - pos["total_cost"], 4)
                        entry["unrealized_label"] = "locked"
                else:
                    entry["unrealized_pnl"] = 0.0
                    entry["unrealized_label"] = "settled"

                positions.append(entry)
            positions.sort(key=lambda x: (0 if x["status"] == "OPEN" else 1, -x["opened_at"]))
            return positions

    def get_trade_history(self, limit=50):
        with self._lock:
            trades = list(self.portfolio["trade_history"])
            trades.reverse()  # newest first
            return trades[:limit]

    def get_pnl_chart_data(self):
        with self._lock:
            return list(self.portfolio["pnl_snapshots"])

    def get_metrics(self):
        with self._lock:
            p = self.portfolio
            total = p["total_trades"]
            snapshots = p["pnl_snapshots"]

            # Basic metrics
            avg_profit = p["total_realized_pnl"] / max(total, 1)

            # Max drawdown from snapshots
            max_dd = 0.0
            peak = 0.0
            for s in snapshots:
                val = s["total_value"]
                if val > peak:
                    peak = val
                dd = (peak - val) / peak if peak > 0 else 0
                if dd > max_dd:
                    max_dd = dd

            # Best/worst trades (by individual fill)
            fills = p["trade_history"]
            best_fill = max(fills, key=lambda f: f.get("size", 0) * (1.0 - f.get("price", 1.0)), default=None)
            worst_fill = min(fills, key=lambda f: f.get("size", 0) * (1.0 - f.get("price", 1.0)), default=None)

            return {
                "total_trades": total,
                "win_rate": round(p["winning_trades"] / max(total, 1) * 100, 1),
                "avg_profit_per_trade": round(avg_profit, 4),
                "total_fees_paid": round(p["total_fees_paid"], 4),
                "total_opportunities_seen": p.get("total_opportunities_seen", 0),
                "max_drawdown_pct": round(max_dd * 100, 2),
                "best_fill": best_fill,
                "worst_fill": worst_fill,
                "snapshots_count": len(snapshots),
            }

    def export_full_state(self):
        """Export complete portfolio state for LLM analysis."""
        with self._lock:
            export = {
                "export_timestamp": time.time(),
                "portfolio": dict(self.portfolio),
                "summary": self.get_portfolio_summary(),
                "metrics": self.get_metrics(),
                "config": {
                    "mode": self.config.get("MODE"),
                    "paper_balance": self.config.get("PAPER_BALANCE"),
                    "min_profit": self.config.get("MIN_PROFIT"),
                    "max_exposure": self.config.get("MAX_EXPOSURE"),
                    "cost_buffer": self.config.get("COST_BUFFER"),
                    "min_liquidity": self.config.get("MIN_LIQUIDITY"),
                    "max_order_size": self.config.get("MAX_ORDER_SIZE"),
                },
            }
            return export


--- FILE: src/paper_fees.py ---
"""Polymarket fee calculation for paper trading simulation."""


def calculate_trading_fee(price, size, fee_rate_bps):
    """
    Polymarket fee formula.
    Most markets: fee_rate_bps=0 (no fee).
    15-min crypto markets: fee_rate_bps=1000 (curved formula).

    Formula: fee_per_unit = fee_rate_bps / 10000 * price * (1 - price)
    """
    if fee_rate_bps <= 0:
        return 0.0

    fee_per_unit = (fee_rate_bps / 10000.0) * price * (1.0 - price)
    return fee_per_unit * size


def calculate_withdrawal_haircut(net_profit, haircut_pct=0.02):
    """2% of net profits, only applies to positive profits."""
    if net_profit <= 0:
        return 0.0
    return net_profit * haircut_pct


def estimate_locked_profit_cost(buy_yes_price, buy_no_price, size,
                                 yes_fee_bps=0, no_fee_bps=0):
    """
    Full cost breakdown for a locked-profit trade.
    Returns dict with all components.
    """
    yes_cost = buy_yes_price * size
    no_cost = buy_no_price * size
    yes_fee = calculate_trading_fee(buy_yes_price, size, yes_fee_bps)
    no_fee = calculate_trading_fee(buy_no_price, size, no_fee_bps)

    total_cost = yes_cost + no_cost + yes_fee + no_fee
    settlement_value = size * 1.00  # both sides settle to $1 total
    gross_profit = settlement_value - total_cost
    withdrawal_fee = calculate_withdrawal_haircut(gross_profit)
    net_profit = gross_profit - withdrawal_fee

    return {
        "yes_cost": round(yes_cost, 6),
        "no_cost": round(no_cost, 6),
        "yes_fee": round(yes_fee, 6),
        "no_fee": round(no_fee, 6),
        "total_cost": round(total_cost, 6),
        "settlement_value": round(settlement_value, 6),
        "gross_profit": round(gross_profit, 6),
        "withdrawal_fee": round(withdrawal_fee, 6),
        "net_profit": round(net_profit, 6),
    }


--- FILE: src/paper_fills.py ---
"""Order book fill simulation for paper trading."""


def simulate_fill(order_book_side, size):
    """
    Walk the order book to simulate a fill.

    Args:
        order_book_side: [[price, size], ...] sorted ascending for asks,
                         descending for bids.
        size: number of shares to fill.

    Returns dict with fill details.
    """
    if not order_book_side or size <= 0:
        return {
            "filled": False,
            "fill_price": 0.0,
            "fill_size": 0.0,
            "slippage": 0.0,
            "levels_consumed": 0,
            "fills": [],
        }

    best_price = float(order_book_side[0][0])
    remaining = size
    total_cost = 0.0
    fills = []
    levels = 0

    for level in order_book_side:
        price = float(level[0])
        available = float(level[1])
        levels += 1

        take = min(remaining, available)
        total_cost += take * price
        fills.append((price, take))
        remaining -= take

        if remaining <= 0:
            break

    filled_size = size - remaining
    if filled_size <= 0:
        return {
            "filled": False,
            "fill_price": 0.0,
            "fill_size": 0.0,
            "slippage": 0.0,
            "levels_consumed": 0,
            "fills": [],
        }

    vwap = total_cost / filled_size
    slippage = abs(vwap - best_price)

    return {
        "filled": remaining <= 0,
        "fill_price": round(vwap, 6),
        "fill_size": round(filled_size, 2),
        "slippage": round(slippage, 6),
        "levels_consumed": levels,
        "fills": fills,
    }


def simulate_two_leg_fill(asks_yes, asks_no, size, yes_fee_bps=0, no_fee_bps=0):
    """
    Simulate filling both legs of a locked-profit trade.

    Returns dict with both fills and combined metrics.
    """
    from src.paper_fees import calculate_trading_fee

    yes_fill = simulate_fill(asks_yes, size)
    no_fill = simulate_fill(asks_no, size)

    both_filled = yes_fill["filled"] and no_fill["filled"]

    yes_fee = calculate_trading_fee(yes_fill["fill_price"], yes_fill["fill_size"], yes_fee_bps)
    no_fee = calculate_trading_fee(no_fill["fill_price"], no_fill["fill_size"], no_fee_bps)

    total_cost = (
        yes_fill["fill_price"] * yes_fill["fill_size"]
        + no_fill["fill_price"] * no_fill["fill_size"]
        + yes_fee + no_fee
    )

    # Use the smaller fill size (can only lock profit on matched amounts)
    matched_size = min(yes_fill["fill_size"], no_fill["fill_size"])
    settlement = matched_size * 1.00
    expected_profit = settlement - total_cost if both_filled else 0.0

    return {
        "yes_fill": yes_fill,
        "no_fill": no_fill,
        "both_filled": both_filled,
        "matched_size": round(matched_size, 2),
        "yes_fee": round(yes_fee, 6),
        "no_fee": round(no_fee, 6),
        "total_cost": round(total_cost, 6),
        "expected_profit": round(expected_profit, 6),
    }


--- FILE: src/records.py ---
import datetime

def log_decision(decision, reason):
    timestamp = datetime.datetime.now().isoformat()
    entry = f"{timestamp} | {decision} | {reason}\n"
    with open("audit_log.txt", "a") as f:
        f.write(entry)


--- FILE: src/risk.py ---
import os
import time

class RiskGuard:
    def __init__(self, config):
        self.config = config
        self.max_exposure = config.get("MAX_EXPOSURE", 25.0)
        self.current_exposure = 0.0
        self.daily_loss = 0.0
        self.max_daily_loss = config.get("MAX_DAILY_LOSS", 15.0)
        self.kill_switch = False
        self._day_start = time.time()

    def update_limits(self, balance, starting_balance):
        """Dynamically update limits based on current account balance."""
        growth = balance / max(starting_balance, 1)
        if growth >= 3.0:
            g = 2.0
        elif growth >= 2.0:
            g = 1.5
        elif growth >= 1.5:
            g = 1.25
        else:
            g = 1.0
        self.max_exposure = balance * self.config.get("RISK_MAX_EXPOSURE_PCT", 0.50) * g
        self.max_daily_loss = balance * self.config.get("RISK_MAX_DAILY_LOSS_PCT", 0.30) * g

    def check_kill_switch(self):
        """Spec 11: Simple file toggle."""
        if os.path.exists("STOP_TRADING"):
            self.kill_switch = True
            return True
        return False

    def can_trade(self, plan):
        if self.check_kill_switch(): return False
        self._check_day_reset()
        if self.daily_loss >= self.max_daily_loss: return False

        estimated_cost = (plan['buy_yes'] + plan['buy_no']) * plan['size']
        if (self.current_exposure + estimated_cost) > self.max_exposure:
            return False

        return True

    def add_exposure(self, amount):
        """Add exposure when a trade fills."""
        self.current_exposure += amount

    def remove_exposure(self, amount):
        """Remove exposure when a position settles."""
        self.current_exposure = max(0.0, self.current_exposure - amount)

    def record_loss(self, amount):
        """Record a realized loss (positive number = loss)."""
        if amount > 0:
            self.daily_loss += amount

    def _check_day_reset(self):
        """Reset daily loss counter at midnight."""
        now = time.time()
        if now - self._day_start >= 86400:
            self.daily_loss = 0.0
            self._day_start = now


--- FILE: src/strategy.py ---
"""Strategy engine optimized for free infrastructure.

Free-infra edge: COVERAGE over speed. We scan all 1000+ markets while
fast bots focus on the top 50. We find arbitrage in the long tail.

Strategy: LOCKED_PROFIT
  Buy YES + NO when ask_yes + ask_no + cost_buffer < $1.00.
  Guaranteed $1.00 payout at settlement regardless of outcome.
  Aggressive thresholds: MIN_PROFIT=0.003, COST_BUFFER=0.002.
"""


def check_opportunity(market_book, config):
    """Check a single market for locked-profit arbitrage.

    Returns a plan dict if opportunity found, None otherwise.
    Plan includes overround tracking for data collection.
    """
    if not market_book:
        return None

    asks_yes = market_book.get('asks_yes', [])
    asks_no = market_book.get('asks_no', [])

    if not asks_yes or not asks_no:
        return None

    best_ask_yes = float(asks_yes[0][0])
    best_ask_no = float(asks_no[0][0])
    best_size_yes = float(asks_yes[0][1])
    best_size_no = float(asks_no[0][1])

    # Liquidity check: need minimum size available on each side
    min_liquidity = config.get("MIN_LIQUIDITY", 0.5)
    if best_size_yes < min_liquidity or best_size_no < min_liquidity:
        return None

    # Size: take the smaller of both sides, capped at max
    max_size = config.get("MAX_ORDER_SIZE", 25.0)
    tradeable_size = min(best_size_yes, best_size_no, max_size)

    # Cost buffer for slippage/rounding (most Polymarket markets: 0 fees)
    cost_buffer = config.get("COST_BUFFER", 0.002)
    min_profit = config.get("MIN_PROFIT", 0.003)

    total_unit_cost = best_ask_yes + best_ask_no + cost_buffer
    overround = round(best_ask_yes + best_ask_no - 1.0, 6)

    if total_unit_cost < 1.00:
        expected_profit = 1.00 - total_unit_cost

        if expected_profit >= min_profit:
            return {
                "type": "LOCKED_PROFIT",
                "condition_id": market_book.get("condition_id"),
                "yes_token_id": market_book.get("yes_token_id"),
                "no_token_id": market_book.get("no_token_id"),
                "buy_yes": best_ask_yes,
                "buy_no": best_ask_no,
                "size": tradeable_size,
                "expected_profit": expected_profit,
                "overround": overround,
            }

    return None


--- FILE: src/stress_sim.py ---
"""Comprehensive stress simulation for pessimistic paper trading.

Simulates every friction source on real Polymarket CLOB trading so
paper results are conservative. If you're profitable under stress,
live trading should perform the same or better.

Friction layers modeled:
  1. Fill rejection      — order book changed before our order lands
  2. Partial fills        — liquidity dries up mid-fill
  3. Variable slippage    — real books have depth variance
  4. Timing drift         — price moves during our detection→execution gap
  5. Signal staleness     — older signals = worse entries
  6. Copy crowd effect    — other bots copy the same whale, push price
  7. Book depletion       — repeated trades in same market thin the book
  8. Rate limiting        — can't spam the CLOB matching engine
  9. API failures         — random network/server errors
 10. Gas fees             — Polygon on-chain transaction costs
 11. Spread widening      — volatile periods have wider spreads
 12. Time-of-day effect   — off-hours have less liquidity
"""

import random
import time

# ── Polymarket Reality Constants ────────────────────────────────
# Calibrated from real CLOB trading conditions.

# 1. Fill reliability
FILL_REJECTION_BASE = 0.08           # 8% base order rejection
FILL_REJECTION_RATE_LIMIT_EXTRA = 0.15  # +15% if trading faster than cooldown
FILL_REJECTION_PER_MARKET_TRADE = 0.05  # +5% per recent trade in same market
FILL_REJECTION_MAX = 0.40            # Cap at 40% rejection rate

PARTIAL_FILL_CHANCE = 0.12           # 12% of fills are partial
PARTIAL_FILL_MIN = 0.35              # Worst partial: 35% of desired
PARTIAL_FILL_MAX = 0.85              # Best partial: 85% of desired

# 2. Slippage model (stacks additively)
SLIPPAGE_BASE = 0.015                # 1.5% base (we're always slower than whale)
SLIPPAGE_RANDOM_MAX = 0.025          # 0-2.5% random market noise
TIMING_DRIFT_MAX = 0.03              # 0-3% price drift during execution
STALENESS_PER_SEC = 0.001            # +0.1% per second of signal age
STALENESS_CAP = 0.05                 # Cap staleness penalty at 5%
CROWD_SLIPPAGE = 0.02                # +2% when high-score signals attract crowd
CROWD_SCORE_THRESHOLD = 4            # Signals scoring >= 4 attract copiers
BOOK_DEPLETION_PER_TRADE = 0.01      # +1% per recent trade in same market
BOOK_DEPLETION_CAP = 0.05            # Cap at 5% depletion penalty
SPREAD_WIDEN_CHANCE = 0.10           # 10% chance of spread widening event
SPREAD_WIDEN_RANGE = (0.01, 0.04)    # 1-4% extra on widening events

# 3. Timing
MIN_TRADE_INTERVAL_SEC = 3.0         # CLOB rate limit simulation
API_FAILURE_CHANCE = 0.03            # 3% random API/network failure

# 4. Costs
GAS_FEE_MIN = 0.001                  # Polygon gas floor (USDC)
GAS_FEE_MAX = 0.008                  # Polygon gas ceiling (USDC)

# 5. Time-of-day liquidity multiplier
# Markets have less liquidity outside US trading hours (14:30-21:00 UTC)
# We model this as a slippage multiplier
OFF_HOURS_SLIPPAGE_MULT = 1.4        # 40% worse slippage outside peak hours
PEAK_HOURS_UTC = (14, 21)            # 14:30-21:00 UTC = US market hours

# 6. Book depletion decay
DEPLETION_DECAY_SECONDS = 30         # Liquidity replenishes: -1 trade per 30s


class StressSimulator:
    """Simulates real-world Polymarket CLOB trading friction.

    Every trade passes through multiple stress layers. The simulator
    tracks what happened so the confidence report can show exactly
    how much friction was applied.
    """

    def __init__(self):
        self._last_trade_time = 0
        # condition_id -> (trade_count, last_trade_timestamp)
        self._market_activity = {}
        self._trade_timestamps = []

        # ── Counters ──
        self.fill_rejections = 0
        self.partial_fills = 0
        self.rate_limit_blocks = 0
        self.api_failures = 0
        self.crowd_hits = 0
        self.spread_widen_hits = 0
        self.off_hours_hits = 0
        self.depletion_hits = 0
        self.total_gas_paid = 0.0
        self.total_extra_slippage = 0.0
        self.total_crowd_penalty = 0.0
        self.total_trades_attempted = 0
        self.total_trades_passed = 0
        self.worst_slippage_pct = 0.0

    # ── Entry Stress (buying) ─────────────────────────────────────

    def stress_entry(self, whale_price, copy_budget, condition_id,
                     signal_score=1, signal_age_sec=0, min_size=0.50):
        """Apply all stress layers to a copy trade entry.

        Args:
            whale_price: Price the whale paid
            copy_budget: How much USDC we want to spend
            condition_id: Market we're trading
            signal_score: Signal quality (higher = more copiers)
            signal_age_sec: Seconds since whale's trade
            min_size: Minimum budget to proceed

        Returns:
            dict with: success, adjusted_price, adjusted_budget, gas_fee,
                       slippage_pct, stress_tags, reason (if failed)
        """
        self.total_trades_attempted += 1
        stress_tags = []
        now = time.time()

        # ── Layer 1: API failure ──
        if random.random() < API_FAILURE_CHANCE:
            self.api_failures += 1
            return self._fail("STRESS: API/network error")

        # ── Layer 2: Rate limiting ──
        time_since_last = now - self._last_trade_time
        if time_since_last < MIN_TRADE_INTERVAL_SEC:
            if random.random() < FILL_REJECTION_RATE_LIMIT_EXTRA:
                self.rate_limit_blocks += 1
                return self._fail("STRESS: Rate limited (too fast)")
            stress_tags.append("FAST")

        # ── Layer 3: Fill rejection ──
        fatigue = self._get_market_fatigue(condition_id, now)
        rejection_chance = min(
            FILL_REJECTION_BASE + (fatigue * FILL_REJECTION_PER_MARKET_TRADE),
            FILL_REJECTION_MAX
        )
        if random.random() < rejection_chance:
            self.fill_rejections += 1
            return self._fail("STRESS: Order rejected (book changed)")

        # ── Layer 4: Partial fill ──
        adjusted_budget = copy_budget
        if random.random() < PARTIAL_FILL_CHANCE:
            fill_pct = random.uniform(PARTIAL_FILL_MIN, PARTIAL_FILL_MAX)
            adjusted_budget = copy_budget * fill_pct
            self.partial_fills += 1
            pct_str = str(int(fill_pct * 100))
            stress_tags.append("PARTIAL(" + pct_str + "%)")
            if adjusted_budget < min_size:
                return self._fail("STRESS: Partial fill too small")

        # ── Layer 5: Slippage calculation (all sub-layers) ──
        total_slip = SLIPPAGE_BASE

        # 5a: Random market noise
        total_slip += random.uniform(0, SLIPPAGE_RANDOM_MAX)

        # 5b: Timing drift
        total_slip += random.uniform(0, TIMING_DRIFT_MAX)

        # 5c: Signal staleness
        if signal_age_sec > 0:
            staleness = min(signal_age_sec * STALENESS_PER_SEC, STALENESS_CAP)
            total_slip += staleness
            if staleness > 0.01:
                stress_tags.append("STALE")

        # 5d: Copy crowd effect
        crowd_penalty = 0.0
        if signal_score >= CROWD_SCORE_THRESHOLD:
            crowd_penalty = CROWD_SLIPPAGE * random.uniform(0.5, 1.5)
            total_slip += crowd_penalty
            self.crowd_hits += 1
            self.total_crowd_penalty += crowd_penalty
            stress_tags.append("CROWD")

        # 5e: Book depletion
        if fatigue > 0:
            depletion = min(fatigue * BOOK_DEPLETION_PER_TRADE, BOOK_DEPLETION_CAP)
            total_slip += depletion
            self.depletion_hits += 1
            stress_tags.append("DEPLETED")

        # 5f: Spread widening event
        if random.random() < SPREAD_WIDEN_CHANCE:
            widen = random.uniform(*SPREAD_WIDEN_RANGE)
            total_slip += widen
            self.spread_widen_hits += 1
            stress_tags.append("WIDE_SPREAD")

        # 5g: Time-of-day liquidity
        hour_utc = time.gmtime(now).tm_hour
        if hour_utc < PEAK_HOURS_UTC[0] or hour_utc >= PEAK_HOURS_UTC[1]:
            # Off-hours: multiply all slippage by penalty factor
            extra_from_off_hours = total_slip * (OFF_HOURS_SLIPPAGE_MULT - 1.0)
            total_slip *= OFF_HOURS_SLIPPAGE_MULT
            self.off_hours_hits += 1
            stress_tags.append("OFF_HOURS")

        # Apply slippage (buying: price goes UP against us)
        adjusted_price = min(whale_price * (1.0 + total_slip), 0.99)

        # Track extra slippage beyond base
        extra = total_slip - SLIPPAGE_BASE
        self.total_extra_slippage += extra
        if total_slip > self.worst_slippage_pct:
            self.worst_slippage_pct = total_slip

        # ── Layer 6: Gas fee ──
        gas = random.uniform(GAS_FEE_MIN, GAS_FEE_MAX)
        self.total_gas_paid += gas

        # ── Update tracking ──
        self._last_trade_time = now
        self._record_market_trade(condition_id, now)
        self._trade_timestamps.append(now)
        # Clean old timestamps
        self._trade_timestamps = [t for t in self._trade_timestamps if now - t < 300]

        self.total_trades_passed += 1

        return {
            "success": True,
            "adjusted_price": round(adjusted_price, 6),
            "adjusted_budget": round(adjusted_budget, 4),
            "gas_fee": round(gas, 4),
            "slippage_pct": round(total_slip * 100, 2),
            "stress_tags": stress_tags,
        }

    # ── Exit Stress (selling) ─────────────────────────────────────

    def stress_exit(self, whale_price, condition_id, signal_age_sec=0):
        """Apply stress to a copy exit (selling our position).

        Returns:
            dict with: success, adjusted_price, gas_fee, slippage_pct,
                       stress_tags, reason (if failed)
        """
        self.total_trades_attempted += 1
        stress_tags = []
        now = time.time()

        # API failure
        if random.random() < API_FAILURE_CHANCE:
            self.api_failures += 1
            return self._fail("STRESS: API error on exit")

        # Slippage (selling: price goes DOWN against us)
        total_slip = SLIPPAGE_BASE
        total_slip += random.uniform(0, SLIPPAGE_RANDOM_MAX)
        total_slip += random.uniform(0, TIMING_DRIFT_MAX)

        # Staleness
        if signal_age_sec > 0:
            staleness = min(signal_age_sec * STALENESS_PER_SEC, STALENESS_CAP)
            total_slip += staleness
            if staleness > 0.01:
                stress_tags.append("STALE")

        # Spread widening
        if random.random() < SPREAD_WIDEN_CHANCE:
            widen = random.uniform(*SPREAD_WIDEN_RANGE)
            total_slip += widen
            self.spread_widen_hits += 1
            stress_tags.append("WIDE_SPREAD")

        # Time-of-day
        hour_utc = time.gmtime(now).tm_hour
        if hour_utc < PEAK_HOURS_UTC[0] or hour_utc >= PEAK_HOURS_UTC[1]:
            total_slip *= OFF_HOURS_SLIPPAGE_MULT
            self.off_hours_hits += 1
            stress_tags.append("OFF_HOURS")

        adjusted_price = max(whale_price * (1.0 - total_slip), 0.01)

        extra = total_slip - SLIPPAGE_BASE
        self.total_extra_slippage += extra
        if total_slip > self.worst_slippage_pct:
            self.worst_slippage_pct = total_slip

        # Gas
        gas = random.uniform(GAS_FEE_MIN, GAS_FEE_MAX)
        self.total_gas_paid += gas

        self.total_trades_passed += 1

        return {
            "success": True,
            "adjusted_price": round(adjusted_price, 6),
            "gas_fee": round(gas, 4),
            "slippage_pct": round(total_slip * 100, 2),
            "stress_tags": stress_tags,
        }

    # ── Market Fatigue Tracking ───────────────────────────────────

    def _get_market_fatigue(self, condition_id, now):
        """How depleted is this market's book from our recent trades?
        Returns 0 (fresh) to N (heavily traded)."""
        entry = self._market_activity.get(condition_id)
        if not entry:
            return 0
        count, last_time = entry
        # Decay: -1 trade per DEPLETION_DECAY_SECONDS
        elapsed = now - last_time
        decayed = max(0, count - int(elapsed / DEPLETION_DECAY_SECONDS))
        return decayed

    def _record_market_trade(self, condition_id, now):
        entry = self._market_activity.get(condition_id)
        if entry:
            old_count = max(0, entry[0] - int((now - entry[1]) / DEPLETION_DECAY_SECONDS))
            self._market_activity[condition_id] = (old_count + 1, now)
        else:
            self._market_activity[condition_id] = (1, now)

    # ── Helpers ───────────────────────────────────────────────────

    def _fail(self, reason):
        return {"success": False, "reason": reason}

    def get_stats(self):
        """Full stress statistics for the confidence report."""
        attempted = max(self.total_trades_attempted, 1)
        rejections = self.fill_rejections + self.rate_limit_blocks + self.api_failures
        return {
            "total_attempted": self.total_trades_attempted,
            "total_passed": self.total_trades_passed,
            "total_rejected": rejections,
            "rejection_rate_pct": round(rejections / attempted * 100, 1),
            "fill_rejections": self.fill_rejections,
            "partial_fills": self.partial_fills,
            "rate_limit_blocks": self.rate_limit_blocks,
            "api_failures": self.api_failures,
            "crowd_hits": self.crowd_hits,
            "spread_widen_hits": self.spread_widen_hits,
            "off_hours_hits": self.off_hours_hits,
            "depletion_hits": self.depletion_hits,
            "total_gas_paid": round(self.total_gas_paid, 4),
            "total_extra_slippage": round(self.total_extra_slippage, 4),
            "total_crowd_penalty": round(self.total_crowd_penalty, 4),
            "worst_slippage_pct": round(self.worst_slippage_pct * 100, 2),
            "avg_slippage_pct": round(
                (self.total_extra_slippage / max(self.total_trades_passed, 1)
                 + SLIPPAGE_BASE) * 100, 2
            ),
        }


--- FILE: src/wallet_scorer.py ---
"""Deep wallet performance tracking, flow analysis, and pattern recognition.

Tracks:
- Per-wallet copy results: wins, losses, ROI, best market types
- Market classification: crypto_fast, sports, politics (auto-skip slow ones)
- Flow clusters: when multiple top wallets agree on same market
- Smart sizing: proven wallets get bigger copies, losers get cut

The goal: follow the money. Find which wallets ACTUALLY make us profit,
rank them, connect the dots, and route capital to the best flows.
"""

import json
import os
import re
import time

SCORER_STATE_FILE = "data/wallet_scores.json"

# Market classification patterns
FAST_CRYPTO_PATTERNS = [
    r"Up or Down",          # BTC/ETH up or down (15-30 min windows)
    r"\d{1,2}:\d{2}[AP]M",  # Contains specific time like "8:30AM"
]
FAST_SPORTS_PATTERNS = [
    r"\bvs\.?\b",           # "Team A vs Team B"
    r"\bBO[1-3]\b",         # Best of 1/2/3 (esports)
    r"\bSet \d\b",          # Tennis sets
    r"\bO/U\b",             # Over/under
    r"\bMatch\b.*\bWinner\b",  # Match winner
    r"win on \d{4}-\d{2}-\d{2}",  # "win on 2026-02-06" (same-day)
]
SLOW_PATTERNS = [
    r"World Cup",
    r"win the 2",           # "win the 2025-26 NBA Championship"
    r"by (March|April|May|June|July|August|September|October|November|December) \d",
    r"by \w+ \d{1,2}, 202[6-9]",  # "by June 30, 2026"
    r"Prime Minister",
    r"largest company",
    r"FDV above",
    r"win the most medals",
    r"next President",
    r"next Prime",
    r"price of Bitcoin be above",  # Long-term price targets
    r"price of Ethereum be above",
    r"tweets from",              # Elon tweet counts (weekly)
    r"most medals",
]


class WalletScorer:
    """Tracks per-wallet copy trading performance and identifies money flow."""

    def __init__(self, config):
        self.config = config
        self.wallet_stats = {}      # wallet -> performance dict
        self.market_types = {}      # condition_id -> classification
        self.flow_events = []       # Recent flow events for cluster detection
        self.cluster_scores = {}    # condition_id -> flow strength
        self._load_state()

    # ── State Persistence ─────────────────────────────────────

    def _load_state(self):
        if os.path.exists(SCORER_STATE_FILE):
            try:
                with open(SCORER_STATE_FILE, "r") as f:
                    state = json.load(f)
                self.wallet_stats = state.get("wallet_stats", {})
                self.market_types = state.get("market_types", {})
                self.flow_events = state.get("flow_events", [])
                total = len(self.wallet_stats)
                scored = sum(1 for w in self.wallet_stats.values() if w.get("total_copies", 0) >= 3)
                print(f"[SCORER] Loaded {total} wallets ({scored} with 3+ copies scored)")
                return
            except Exception:
                pass
        print("[SCORER] Starting fresh — will build wallet scores from copy results")

    def _save_state(self):
        os.makedirs(os.path.dirname(SCORER_STATE_FILE), exist_ok=True)
        try:
            # Trim flow events to last 2000
            if len(self.flow_events) > 2000:
                self.flow_events = self.flow_events[-2000:]
            # Trim market types cache to last 500
            if len(self.market_types) > 500:
                keys = list(self.market_types.keys())
                self.market_types = {k: self.market_types[k] for k in keys[-500:]}

            state = {
                "wallet_stats": self.wallet_stats,
                "market_types": self.market_types,
                "flow_events": self.flow_events,
                "last_updated": time.time(),
            }
            with open(SCORER_STATE_FILE, "w") as f:
                json.dump(state, f)
        except Exception as e:
            print(f"[!] Scorer state save error: {e}")

    # ── Market Classification ─────────────────────────────────

    def classify_market(self, title, condition_id=None):
        """Classify a market by settlement speed and type.

        Returns: 'crypto_fast', 'sports_fast', 'slow', or 'unknown'
        """
        if condition_id and condition_id in self.market_types:
            return self.market_types[condition_id]

        title_upper = title.upper() if title else ""
        classification = "unknown"

        # Check slow patterns first (these override fast)
        for pattern in SLOW_PATTERNS:
            if re.search(pattern, title, re.IGNORECASE):
                classification = "slow"
                break

        if classification != "slow":
            # Check fast crypto
            for pattern in FAST_CRYPTO_PATTERNS:
                if re.search(pattern, title, re.IGNORECASE):
                    classification = "crypto_fast"
                    break

            # Check fast sports
            if classification == "unknown":
                for pattern in FAST_SPORTS_PATTERNS:
                    if re.search(pattern, title, re.IGNORECASE):
                        classification = "sports_fast"
                        break

        if condition_id:
            self.market_types[condition_id] = classification

        return classification

    def is_fast_market(self, title, condition_id=None):
        """Returns True if market likely settles within 24h."""
        mtype = self.classify_market(title, condition_id)
        return mtype in ("crypto_fast", "sports_fast")

    def is_bitcoin_market(self, title):
        """Returns True for any Bitcoin/BTC market (not just Up or Down)."""
        if not title:
            return False
        t = title.lower()
        return "bitcoin" in t or "btc" in t

    # ── Entry/Exit Recording ──────────────────────────────────

    def record_entry(self, wallet, condition_id, cost, market_title, score):
        """Called when we open a copy position."""
        stats = self._get_or_create(wallet)
        stats["total_copies"] += 1
        stats["total_invested"] += cost
        stats["last_copy_at"] = time.time()

        # Track market type affinity
        mtype = self.classify_market(market_title, condition_id)
        if mtype not in stats["market_types"]:
            stats["market_types"][mtype] = {"copies": 0, "wins": 0, "losses": 0, "pnl": 0.0}
        stats["market_types"][mtype]["copies"] += 1

        # Record flow event (for cluster detection)
        self.flow_events.append({
            "timestamp": time.time(),
            "wallet": wallet,
            "condition_id": condition_id,
            "market_title": market_title[:50],
            "market_type": mtype,
            "direction": "BUY",
            "cost": round(cost, 4),
        })

        # Update cluster scores (how many wallets are buying this market)
        self._update_clusters(condition_id)

    def record_result(self, wallet, condition_id, realized_pnl, hold_seconds, market_title=""):
        """Called when a copy position settles or is exit-copied."""
        stats = self._get_or_create(wallet)

        if realized_pnl >= 0:
            stats["wins"] += 1
            stats["total_profit"] += realized_pnl
            stats["streak"] = max(0, stats.get("streak", 0)) + 1
        else:
            stats["losses"] += 1
            stats["total_loss"] += abs(realized_pnl)
            stats["streak"] = min(0, stats.get("streak", 0)) - 1

        stats["net_pnl"] += realized_pnl

        # Track best and worst result
        if realized_pnl > stats.get("best_trade_pnl", 0):
            stats["best_trade_pnl"] = round(realized_pnl, 4)
        if realized_pnl < stats.get("worst_trade_pnl", 0):
            stats["worst_trade_pnl"] = round(realized_pnl, 4)

        # Track hold time
        total_holds = stats.get("total_hold_seconds", 0) + hold_seconds
        hold_count = stats["wins"] + stats["losses"]
        stats["total_hold_seconds"] = total_holds
        stats["avg_hold_minutes"] = round(total_holds / max(hold_count, 1) / 60, 1)

        # Update market type stats
        mtype = self.classify_market(market_title, condition_id)
        if mtype in stats["market_types"]:
            type_stats = stats["market_types"][mtype]
            if realized_pnl >= 0:
                type_stats["wins"] += 1
            else:
                type_stats["losses"] += 1
            type_stats["pnl"] += realized_pnl

        # Recalculate composite score
        stats["score"] = self._calculate_score(stats)

        self._save_state()

    def _get_or_create(self, wallet):
        if wallet not in self.wallet_stats:
            self.wallet_stats[wallet] = {
                "wallet": wallet,
                "total_copies": 0,
                "total_invested": 0.0,
                "wins": 0,
                "losses": 0,
                "total_profit": 0.0,
                "total_loss": 0.0,
                "net_pnl": 0.0,
                "best_trade_pnl": 0.0,
                "worst_trade_pnl": 0.0,
                "streak": 0,
                "total_hold_seconds": 0,
                "avg_hold_minutes": 0.0,
                "market_types": {},
                "score": 1.0,
                "first_copy_at": time.time(),
                "last_copy_at": 0,
            }
        return self.wallet_stats[wallet]

    # ── Scoring Engine ────────────────────────────────────────

    def _calculate_score(self, stats):
        """Calculate wallet score from 0.0 (cut off) to 3.0 (max allocation).

        Based on actual copy results, not leaderboard PnL.
        This is OUR data — how much money did copying this wallet make US.
        """
        copies = stats["total_copies"]
        if copies < 3:
            return 1.0  # Not enough data, use default

        wins = stats["wins"]
        losses = stats["losses"]
        settled = wins + losses
        if settled == 0:
            return 1.0  # No results yet

        win_rate = wins / settled
        invested = max(stats["total_invested"], 0.01)
        roi = stats["net_pnl"] / invested

        # Base score
        score = 1.0

        # Win rate component (0.3 weight)
        if win_rate >= 0.70:
            score += 0.6
        elif win_rate >= 0.55:
            score += 0.3
        elif win_rate < 0.35:
            score -= 0.5

        # ROI component (0.4 weight) — this is the money metric
        if roi >= 0.15:
            score += 0.8       # 15%+ ROI = excellent
        elif roi >= 0.05:
            score += 0.4       # 5-15% ROI = good
        elif roi >= 0.0:
            pass               # Break-even
        elif roi >= -0.10:
            score -= 0.3       # Losing a bit
        else:
            score -= 0.8       # Losing badly

        # Volume component — more settled trades = more reliable
        if settled >= 10:
            score += 0.3
        elif settled >= 5:
            score += 0.1

        # Streak component
        streak = stats.get("streak", 0)
        if streak >= 3:
            score += 0.3       # Hot streak
        elif streak <= -3:
            score -= 0.3       # Cold streak

        # Clamp
        return round(max(0.0, min(3.0, score)), 2)

    def get_wallet_multiplier(self, wallet):
        """Returns sizing multiplier for a wallet.

        0.0 = stop copying (proven loser)
        0.5 = reduce size (underperforming)
        1.0 = normal (default / unproven)
        1.5 = increase (good performer)
        2.0 = max allocation (proven winner)
        3.0 = ultra allocation (exceptional, 70%+ win rate with volume)
        """
        stats = self.wallet_stats.get(wallet)
        if not stats:
            return 1.0

        score = stats.get("score", 1.0)

        # Hard cutoff: if wallet has 5+ results and score below 0.3, stop copying
        settled = stats["wins"] + stats["losses"]
        if settled >= 5 and score < 0.3:
            return 0.0

        return score

    # ── Anti-Hedge Detection ──────────────────────────────────

    def check_anti_hedge(self, condition_id, outcome, open_positions):
        """Check if we already have the opposite side of this market.

        Returns True if safe to proceed, False if it would create a hedge.
        """
        outcome_upper = outcome.upper()

        for pos_key, pos in open_positions.items():
            if pos.get("status") != "OPEN":
                continue
            if pos.get("trade_type") != "COPY":
                continue
            if pos.get("condition_id") != condition_id:
                continue

            existing_outcome = pos.get("outcome", "").upper()

            # Same market, different outcome = hedge
            if existing_outcome != outcome_upper:
                return False

        return True

    # ── Flow & Cluster Analysis ───────────────────────────────

    def _update_clusters(self, condition_id):
        """Update flow cluster scores based on recent activity."""
        now = time.time()
        window = 600  # 10-minute window for cluster detection

        # Count unique wallets buying this market in the last 10 minutes
        recent_wallets = set()
        for event in reversed(self.flow_events):
            if now - event["timestamp"] > window:
                break
            if event["condition_id"] == condition_id and event["direction"] == "BUY":
                recent_wallets.add(event["wallet"])

        self.cluster_scores[condition_id] = {
            "wallets": len(recent_wallets),
            "last_updated": now,
        }

    def get_flow_strength(self, condition_id):
        """How many wallets are flowing into this market right now?

        Returns: number of unique wallets that bought in last 10 min.
        Higher = stronger consensus = bigger copy.
        """
        cluster = self.cluster_scores.get(condition_id, {})
        # Stale check (older than 15 min = 0)
        if time.time() - cluster.get("last_updated", 0) > 900:
            return 0
        return cluster.get("wallets", 0)

    def get_hot_flows(self, min_wallets=2, top_n=10):
        """Find markets with the most smart money flowing in right now.

        These are the markets where multiple tracked wallets are buying
        within a short time window — strongest copy signals.
        """
        now = time.time()
        flows = []

        for cid, cluster in self.cluster_scores.items():
            if now - cluster.get("last_updated", 0) > 900:
                continue
            wallet_count = cluster.get("wallets", 0)
            if wallet_count >= min_wallets:
                # Find the market title from flow events
                title = ""
                for event in reversed(self.flow_events):
                    if event["condition_id"] == cid:
                        title = event.get("market_title", "")
                        break

                # Calculate average wallet score for this flow
                flow_wallets = set()
                for event in reversed(self.flow_events):
                    if now - event["timestamp"] > 600:
                        break
                    if event["condition_id"] == cid:
                        flow_wallets.add(event["wallet"])

                avg_score = 0.0
                if flow_wallets:
                    scores = [self.wallet_stats.get(w, {}).get("score", 1.0)
                              for w in flow_wallets]
                    avg_score = sum(scores) / len(scores)

                flows.append({
                    "condition_id": cid,
                    "market_title": title,
                    "wallets_in": wallet_count,
                    "avg_wallet_score": round(avg_score, 2),
                    "flow_strength": round(wallet_count * avg_score, 2),
                })

        flows.sort(key=lambda f: f["flow_strength"], reverse=True)
        return flows[:top_n]

    # ── Rankings & Reports ────────────────────────────────────

    def get_rankings(self, top_n=50):
        """Return wallets ranked by our ROI from copying them.

        This is THE key metric: which wallets make US money?
        """
        ranked = []
        for wallet, stats in self.wallet_stats.items():
            settled = stats["wins"] + stats["losses"]
            invested = max(stats["total_invested"], 0.01)

            ranked.append({
                "wallet": wallet[:10] + "...",
                "full_wallet": wallet,
                "total_copies": stats["total_copies"],
                "settled": settled,
                "wins": stats["wins"],
                "losses": stats["losses"],
                "win_rate": round(stats["wins"] / max(settled, 1) * 100, 1),
                "net_pnl": round(stats["net_pnl"], 4),
                "roi": round(stats["net_pnl"] / invested * 100, 1),
                "total_invested": round(stats["total_invested"], 2),
                "score": stats.get("score", 1.0),
                "streak": stats.get("streak", 0),
                "avg_hold_min": stats.get("avg_hold_minutes", 0),
                "best_market_type": self._best_market_type(stats),
            })

        # Sort by net PnL (money talks)
        ranked.sort(key=lambda w: w["net_pnl"], reverse=True)
        return ranked[:top_n]

    def _best_market_type(self, stats):
        """Find which market type this wallet performs best in."""
        best_type = "unknown"
        best_pnl = -999
        for mtype, type_stats in stats.get("market_types", {}).items():
            if type_stats.get("pnl", 0) > best_pnl and type_stats.get("copies", 0) >= 2:
                best_pnl = type_stats["pnl"]
                best_type = mtype
        return best_type

    def get_market_type_stats(self):
        """Aggregate stats by market type across all wallets."""
        type_totals = {}

        for wallet, stats in self.wallet_stats.items():
            for mtype, type_stats in stats.get("market_types", {}).items():
                if mtype not in type_totals:
                    type_totals[mtype] = {
                        "copies": 0, "wins": 0, "losses": 0,
                        "pnl": 0.0, "wallets": 0,
                    }
                t = type_totals[mtype]
                t["copies"] += type_stats.get("copies", 0)
                t["wins"] += type_stats.get("wins", 0)
                t["losses"] += type_stats.get("losses", 0)
                t["pnl"] += type_stats.get("pnl", 0)
                if type_stats.get("copies", 0) > 0:
                    t["wallets"] += 1

        for mtype, t in type_totals.items():
            settled = t["wins"] + t["losses"]
            t["win_rate"] = round(t["wins"] / max(settled, 1) * 100, 1)
            t["pnl"] = round(t["pnl"], 4)

        return type_totals

    def get_summary(self):
        """High-level scorer summary for status display."""
        total = len(self.wallet_stats)
        scored = sum(1 for w in self.wallet_stats.values()
                     if (w["wins"] + w["losses"]) >= 3)
        cutoff = sum(1 for w in self.wallet_stats.values()
                     if w.get("score", 1.0) < 0.3 and (w["wins"] + w["losses"]) >= 5)
        hot = sum(1 for w in self.wallet_stats.values()
                  if w.get("score", 1.0) >= 2.0)
        total_pnl = sum(w["net_pnl"] for w in self.wallet_stats.values())

        return {
            "total_tracked": total,
            "scored_wallets": scored,
            "hot_wallets": hot,
            "cutoff_wallets": cutoff,
            "total_copy_pnl": round(total_pnl, 4),
            "active_flows": len([c for c in self.cluster_scores.values()
                                 if time.time() - c.get("last_updated", 0) < 900]),
            "market_type_stats": self.get_market_type_stats(),
        }


--- FILE: src/web_server.py ---
"""Web server for the 60s retro paper trading dashboard.
Uses stdlib http.server — no Flask dependency needed.

Security: All routes require ?token=<DASHBOARD_TOKEN> query param.
Dashboard is READ-ONLY — no control endpoints, no write access.
Default bind: 127.0.0.1 (localhost only). Set DASHBOARD_BIND=0.0.0.0 for cloud."""

import threading
import json
import time
import os
from http.server import ThreadingHTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs


class RetroRequestHandler(BaseHTTPRequestHandler):
    """HTTP handler with token-authenticated JSON API routes."""

    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path
        params = parse_qs(parsed.query)

        # ── Token authentication ──
        # Every request must include ?token=<DASHBOARD_TOKEN>
        expected_token = self.server.dashboard_token
        provided_token = params.get("token", [""])[0]

        if not expected_token or provided_token != expected_token:
            self._send_json({"error": "Unauthorized. Add ?token=YOUR_TOKEN to the URL."}, 401)
            return

        routes = {
            "/": self._serve_index,
            "/api/status": self._api_status,
            "/api/portfolio": self._api_portfolio,
            "/api/positions": self._api_positions,
            "/api/trades": self._api_trades,
            "/api/markets": self._api_markets,
            "/api/risk": self._api_risk,
            "/api/charts/pnl": self._api_chart_pnl,
            "/api/metrics": self._api_metrics,
            "/api/export": self._api_export,
            "/api/data": self._api_data_stats,
            "/api/whales": self._api_whales,
            "/api/scorer": self._api_scorer,
            "/api/flows": self._api_flows,
            "/api/stress": self._api_stress,
        }

        handler = routes.get(path)
        if handler:
            handler()
        else:
            self.send_error(404)

    # ── Static Files ─────────────────────────────────────────────

    def _serve_index(self):
        html_path = os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "static", "index.html"
        )
        try:
            with open(html_path, "r") as f:
                content = f.read()
            self._send_html(content)
        except FileNotFoundError:
            self._send_html("<h1>static/index.html not found</h1>", 404)

    # ── API Routes ───────────────────────────────────────────────

    def _api_status(self):
        bot = self.server.bot_ref
        pe = self.server.paper_engine

        # Speed metrics
        total_markets = len(bot._current_markets)
        hot_count = sum(1 for v in bot._market_heat.values() if v < 0.01)
        rotation_pct = round(bot._market_offset / max(total_markets, 1) * 100)

        data = {
            "mode": bot.config.get("MODE", "?"),
            "running": bot.running,
            "uptime_seconds": round(time.time() - bot._start_time, 0),
            "markets_watching": total_markets,
            "cycle_count": bot._cycle_count,
            "markets_per_cycle": bot._markets_per_cycle,
            "rotation_pct": rotation_pct,
            "hot_markets": hot_count,
            "snapshots": bot.collector._snap_count,
        }

        if pe:
            summary = pe.get_portfolio_summary()
            data.update({
                "balance": summary["cash_balance"],
                "total_value": summary["total_value"],
                "net_profit": summary["net_profit"],
                "total_trades": summary["total_trades"],
                "open_positions": summary["open_positions"],
            })

        self._send_json(data)

    def _api_portfolio(self):
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"error": "Paper trading not active"})
            return
        self._send_json(pe.get_portfolio_summary())

    def _api_positions(self):
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"positions": []})
            return
        self._send_json({"positions": pe.get_positions()})

    def _api_trades(self):
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"trades": []})
            return
        self._send_json({"trades": pe.get_trade_history(limit=100)})

    def _api_markets(self):
        bot = self.server.bot_ref
        heat = bot._market_heat

        # Show hottest markets (closest to arb) instead of first 10
        if heat:
            hot_sorted = sorted(heat.items(), key=lambda x: x[1])[:15]
            market_list = []
            for cid, overround in hot_sorted:
                market_list.append({
                    "condition_id": cid[:20] + "...",
                    "overround": round(overround, 4),
                    "status": "ARB" if overround < 0 else "NEAR" if overround < 0.01 else "WATCH",
                })
        else:
            market_list = [
                {"condition_id": m.get("condition_id", "")[:20] + "...",
                 "overround": round(m.get("yes_price", 0) + m.get("no_price", 0) - 1.0, 4),
                 "status": "SCANNING"}
                for m in bot._current_markets[:15]
            ]
        self._send_json({"markets": market_list, "total_tracked": len(heat)})

    def _api_risk(self):
        bot = self.server.bot_ref
        self._send_json({
            "max_exposure": bot.risk.max_exposure,
            "current_exposure": bot.risk.current_exposure,
            "daily_loss": bot.risk.daily_loss,
            "max_daily_loss": bot.risk.max_daily_loss,
            "kill_switch": bot.risk.kill_switch,
            "kill_switch_file": os.path.exists("STOP_TRADING"),
        })

    def _api_chart_pnl(self):
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"data": []})
            return
        self._send_json({"data": pe.get_pnl_chart_data()})

    def _api_metrics(self):
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"error": "Paper trading not active"})
            return
        self._send_json(pe.get_metrics())

    def _api_export(self):
        """Export complete portfolio state + config for LLM analysis."""
        pe = self.server.paper_engine
        bot = self.server.bot_ref
        if not pe:
            self._send_json({"error": "Paper trading not active"})
            return

        export = pe.export_full_state()

        # Add data collection stats
        if hasattr(bot, "collector"):
            export["data_collection"] = bot.collector.get_stats()

        self._send_json(export)

    def _api_data_stats(self):
        """Return data collection stats for the UI."""
        bot = self.server.bot_ref
        if hasattr(bot, "collector"):
            self._send_json(bot.collector.get_stats())
        else:
            self._send_json({"enabled": False})

    def _api_whales(self):
        """Return whale tracking data: tracked wallets, recent signals, stats."""
        bot = self.server.bot_ref
        wt = bot.whale_tracker
        data = {
            "wallets": wt.get_tracked_wallets(),
            "signals": wt.get_recent_signals(limit=30),
            "stats": wt.get_stats(),
            "copy_trades_executed": bot._copy_trades,
            "copy_exits_executed": bot._copy_exits,
        }
        # Include scorer summary for dashboard whale intelligence panel
        if hasattr(bot, "wallet_scorer"):
            data["scorer"] = bot.wallet_scorer.get_summary()
        self._send_json(data)

    def _api_scorer(self):
        """Return wallet performance rankings and scoring data."""
        bot = self.server.bot_ref
        if not hasattr(bot, "wallet_scorer"):
            self._send_json({"error": "Wallet scorer not active"})
            return
        scorer = bot.wallet_scorer
        self._send_json({
            "summary": scorer.get_summary(),
            "rankings": scorer.get_rankings(top_n=50),
            "market_type_stats": scorer.get_market_type_stats(),
        })

    def _api_flows(self):
        """Return current money flow analysis — where smart money is going."""
        bot = self.server.bot_ref
        if not hasattr(bot, "wallet_scorer"):
            self._send_json({"flows": []})
            return
        scorer = bot.wallet_scorer
        self._send_json({
            "hot_flows": scorer.get_hot_flows(min_wallets=2, top_n=10),
            "summary": scorer.get_summary(),
        })

    def _api_stress(self):
        """Return stress simulation statistics."""
        pe = self.server.paper_engine
        if not pe:
            self._send_json({"error": "Paper trading not active"})
            return
        self._send_json(pe.stress.get_stats())

    # ── Response Helpers ─────────────────────────────────────────

    def _send_json(self, data, status=200):
        body = json.dumps(data).encode()
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def _send_html(self, content, status=200):
        body = content.encode()
        self.send_response(status)
        self.send_header("Content-Type", "text/html; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def log_message(self, format, *args):
        pass  # Suppress per-request logging to keep console clean


class RetroHTTPServer(ThreadingHTTPServer):
    """HTTP server that holds references to bot and paper engine."""

    def __init__(self, server_address, handler_class, bot, paper_engine, token):
        self.bot_ref = bot
        self.paper_engine = paper_engine
        self.dashboard_token = token
        super().__init__(server_address, handler_class)


def start_web_server(config, bot):
    """Start the web server in a daemon thread. Returns the thread."""
    port = config.get("WEB_PORT", 8080)
    bind = config.get("DASHBOARD_BIND", "127.0.0.1")
    token = config.get("DASHBOARD_TOKEN", "")

    paper_engine = None
    if hasattr(bot, "execution") and hasattr(bot.execution, "paper_engine"):
        paper_engine = bot.execution.paper_engine

    server = RetroHTTPServer(
        (bind, port), RetroRequestHandler, bot, paper_engine, token
    )

    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()

    # Print the access URL with token so user can click/copy
    if bind == "127.0.0.1":
        url = f"http://localhost:{port}/?token={token}"
        print(f"[*] Dashboard: {url}")
        print(f"[*] Local only. Set DASHBOARD_BIND=0.0.0.0 in config for network access.")
    else:
        url = f"http://0.0.0.0:{port}/?token={token}"
        print(f"[*] Dashboard: {url}")
        print(f"[*] WARNING: Accessible from network. Token required for access.")

    return thread


--- FILE: src/whale_tracker.py ---
"""Whale tracker: discover and copy mid-tier profitable Polymarket traders.

Mass tracking strategy:
- Paginate the leaderboard to find 300+ traders with $3k-$10k monthly PnL
- Poll their activity round-robin (one wallet per bot cycle)
- Network discovery: when a tracked trader trades a market, find other
  profitable wallets in that same market and add them to the pool

Uses the public Polymarket Data API (no auth required):
- Leaderboard: GET https://data-api.polymarket.com/v1/leaderboard
- Activity:    GET https://data-api.polymarket.com/activity?user=<wallet>
- Trades:      GET https://data-api.polymarket.com/trades?market=<conditionId>

All endpoints are public. No wallet or API key needed.
"""

import json
import time
import os
import requests

DATA_API = "https://data-api.polymarket.com"
WHALE_STATE_FILE = "data/whale_state.json"
LEADERBOARD_REFRESH = 3600          # Re-fetch leaderboard every hour
ACTIVITY_POLL_INTERVAL = 2          # Poll each wallet every 2 seconds
MAX_TRACKED_WALLETS = 1000          # Cap to avoid state file bloat
MIN_TRADE_SIZE_USDC = 25            # Copy trades > $25
LEADERBOARD_PAGE_SIZE = 50          # API max per page
PNL_MIN = 3000                      # Min monthly PnL to track ($3k)
PNL_MAX = 999999                    # No ceiling — forensic filters handle quality
MIN_VOLUME = 5000                   # Min monthly volume ($5k = active trader)
MIN_PNL_RATIO = 0.05                # Farmer Test: PnL/Volume > 5% (filters volume farmers)
MAX_INACTIVE_DAYS = 7               # Skip wallets with no trade in 7 days
NETWORK_DISCOVERY_INTERVAL = 1800   # Network scan every 30 min
NETWORK_DISCOVERY_MIN_PNL = 1000    # Min PnL for network-discovered wallets
MIN_AVG_HOLD_HOURS = 0.25            # Swing Test: avg hold > 15min (catches micro-bots, allows 15-min markets)
SEED_HISTORY_LIMIT = 50             # Trades to fetch for forensic analysis
MAX_WASH_RATIO = 0.30               # Wash Test: max % of round-trip trades
MIN_BTC_RATIO = 1.00                # Bitcoin Focus: 100% of trades must be BTC (pure BTC only)


class WhaleTracker:
    """Discovers and monitors profitable Polymarket traders for copy trading."""

    def __init__(self, config, wallet_scorer=None):
        self.config = config
        self.scorer = wallet_scorer
        self._session = requests.Session()
        self._session.headers.update({"Accept": "application/json"})
        self.tracked_wallets = {}       # proxy_wallet -> wallet_info
        self.network_wallets = {}       # wallets discovered via network (separate pool)
        self.recent_signals = []        # Copy signals for display/history
        self._last_leaderboard_fetch = 0
        self._last_network_scan = 0
        self._seen_tx_hashes = set()
        self._hot_markets = {}          # condition_id -> set of wallets trading it
        self._poll_errors = 0
        self._slow_skips = 0            # Markets skipped for being slow
        self._discovery_stats = {"leaderboard": 0, "network": 0, "pages_fetched": 0}
        self._load_state()

    # ── State Persistence ─────────────────────────────────────

    def _load_state(self):
        if os.path.exists(WHALE_STATE_FILE):
            try:
                with open(WHALE_STATE_FILE, "r") as f:
                    state = json.load(f)
                self.tracked_wallets = state.get("tracked_wallets", {})
                self.network_wallets = state.get("network_wallets", {})
                self._seen_tx_hashes = set(state.get("seen_tx_hashes", []))
                self._hot_markets = {
                    k: set(v) for k, v in state.get("hot_markets", {}).items()
                }
                total = len(self.tracked_wallets) + len(self.network_wallets)
                print(f"[WHALE] Loaded {len(self.tracked_wallets)} leaderboard + "
                      f"{len(self.network_wallets)} network wallets, "
                      f"{len(self._seen_tx_hashes)} seen txs")
                return
            except Exception:
                pass
        print("[WHALE] Starting fresh — will discover traders from leaderboard")

    def _save_state(self):
        os.makedirs(os.path.dirname(WHALE_STATE_FILE), exist_ok=True)
        try:
            # Trim seen hashes for state FILE only — never touch the in-memory set
            # (destroying the in-memory set causes historical trades to re-fire as signals)
            seen_list = list(self._seen_tx_hashes)
            if len(seen_list) > 50000:
                seen_list = seen_list[-50000:]

            # Trim hot_markets to last 100 markets
            hot = dict(list(self._hot_markets.items())[-100:])

            state = {
                "tracked_wallets": self.tracked_wallets,
                "network_wallets": self.network_wallets,
                "seen_tx_hashes": seen_list,
                "hot_markets": {k: list(v) for k, v in hot.items()},
                "last_updated": time.time(),
            }
            with open(WHALE_STATE_FILE, "w") as f:
                json.dump(state, f)
        except Exception as e:
            print(f"[!] Whale state save error: {e}")

    # ── Leaderboard Discovery (paginated) ────────────────────

    def discover_whales(self):
        """Paginate leaderboard to find all traders with $3k-$10k monthly PnL."""
        now = time.time()
        if now - self._last_leaderboard_fetch < LEADERBOARD_REFRESH:
            return

        print("[WHALE] Scanning leaderboard for $3k-$10k/month traders...")

        all_traders = []
        offset = 0
        pages = 0
        empty_streak = 0

        while True:
            try:
                resp = self._session.get(
                    f"{DATA_API}/v1/leaderboard",
                    params={
                        "timePeriod": "MONTH",
                        "orderBy": "PNL",
                        "limit": LEADERBOARD_PAGE_SIZE,
                        "offset": offset,
                    },
                    timeout=15,
                )
                resp.raise_for_status()
                traders = resp.json()
            except Exception as e:
                print(f"[!] Leaderboard page {pages} failed: {e}")
                break

            if not isinstance(traders, list) or len(traders) == 0:
                break

            pages += 1

            # Filter by PnL range + activity metrics
            qualified = []
            below_min = 0
            filtered_out = 0
            for t in traders:
                pnl = float(t.get("pnl", 0))
                vol = float(t.get("vol", 0))

                if pnl < PNL_MIN:
                    below_min += 1
                    continue
                if pnl > PNL_MAX:
                    continue

                # Activity filters
                if vol < MIN_VOLUME:
                    filtered_out += 1
                    continue
                if vol > 0 and (pnl / vol) < MIN_PNL_RATIO:
                    filtered_out += 1
                    continue

                qualified.append(t)

            all_traders.extend(qualified)

            # If most traders on this page are below our min, we're done
            if below_min > LEADERBOARD_PAGE_SIZE * 0.8:
                empty_streak += 1
                if empty_streak >= 2:
                    break
            else:
                empty_streak = 0

            # Safety cap
            if len(all_traders) >= MAX_TRACKED_WALLETS or pages >= 50:
                break

            offset += LEADERBOARD_PAGE_SIZE
            time.sleep(0.3)  # Gentle rate limiting

        self._discovery_stats["pages_fetched"] = pages

        # Register discovered traders
        new_wallets = []
        for trader in all_traders:
            wallet = trader.get("proxyWallet", "")
            if not wallet:
                continue

            is_new = wallet not in self.tracked_wallets
            self.tracked_wallets[wallet] = {
                "proxy_wallet": wallet,
                "username": trader.get("userName", ""),
                "pnl": trader.get("pnl", 0),
                "volume": trader.get("vol", 0),
                "rank": trader.get("rank", "?"),
                "source": "leaderboard",
                "last_poll": self.tracked_wallets.get(wallet, {}).get("last_poll", 0),
                "trades_copied": self.tracked_wallets.get(wallet, {}).get("trades_copied", 0),
            }

            if is_new:
                new_wallets.append(wallet)

        self._last_leaderboard_fetch = now
        self._discovery_stats["leaderboard"] = len(self.tracked_wallets)

        # Seed history for new wallets and apply forensic filters
        seeded = 0
        filter_counts = {"inactive": 0, "hft": 0, "wash": 0, "farmer": 0, "non_btc": 0}
        for wallet in new_wallets:
            result = self._seed_history(wallet)
            seeded += 1
            if result != "active":
                self.tracked_wallets.pop(wallet, None)
                if result in filter_counts:
                    filter_counts[result] += 1
            if seeded % 20 == 0:
                time.sleep(0.5)  # Pace the seeding

        self._save_state()
        self._discovery_stats["filters"] = filter_counts

        removed = sum(filter_counts.values())
        print(f"[WHALE] Leaderboard: {len(all_traders)} qualified, "
              f"{len(self.tracked_wallets)} active wallets tracked ({pages} pages)")
        if removed > 0:
            print(f"[WHALE] Filters: {filter_counts['inactive']} inactive, "
                  f"{filter_counts['hft']} HFT/scalpers, "
                  f"{filter_counts['wash']} wash traders, "
                  f"{filter_counts['farmer']} farmers, "
                  f"{filter_counts['non_btc']} non-BTC removed")

    def _seed_history(self, wallet):
        """Fetch recent trades, mark as seen, and apply forensic filters.

        Returns 'active' if wallet passes all checks, or a filter reason string
        ('inactive', 'hft', 'wash') if it fails.
        """
        trades = self._fetch_recent_activity(wallet)
        if not trades:
            return "inactive"

        now = time.time()
        most_recent = 0
        for trade in trades:
            tx_hash = trade.get("transactionHash", "")
            if tx_hash:
                self._seen_tx_hashes.add(tx_hash)
            ts = float(trade.get("timestamp", 0))
            if ts > most_recent:
                most_recent = ts

        # Check recency
        if most_recent > 0:
            days_ago = (now - most_recent) / 86400
            if days_ago > MAX_INACTIVE_DAYS:
                return "inactive"
        else:
            return "inactive"

        # ── Swing Test: filter out HFT/scalpers ──
        # Calculate avg hold time from BUY→SELL pairs on same market
        by_market = {}
        timestamps = []
        for t in trades:
            cid = t.get("conditionId", "")
            if cid:
                by_market.setdefault(cid, []).append(t)
            ts = float(t.get("timestamp", 0))
            if ts > 0:
                timestamps.append(ts)

        hold_hours = []
        for cid, market_trades in by_market.items():
            market_trades.sort(key=lambda x: float(x.get("timestamp", 0)))
            last_buy_ts = None
            for t in market_trades:
                side = t.get("side", "").upper()
                ts = float(t.get("timestamp", 0))
                if side == "BUY":
                    last_buy_ts = ts
                elif side == "SELL" and last_buy_ts is not None:
                    hold_h = (ts - last_buy_ts) / 3600.0
                    if hold_h > 0:
                        hold_hours.append(hold_h)
                    last_buy_ts = None

        if len(hold_hours) >= 3:
            avg_hold = sum(hold_hours) / len(hold_hours)
            if avg_hold < MIN_AVG_HOLD_HOURS:
                return "hft"
        elif len(timestamps) >= 20:
            # Fallback: if 20+ trades packed into < 2 hours, it's a bot
            timestamps.sort()
            span_hours = (timestamps[-1] - timestamps[0]) / 3600.0
            if span_hours > 0 and span_hours < 2:
                return "hft"

        # ── Wash Test: detect round-trip wash trading ──
        # BUY + SELL same market within 30 min at similar price = suspicious
        wash_count = 0
        total_pairs = 0
        for cid, market_trades in by_market.items():
            market_trades.sort(key=lambda x: float(x.get("timestamp", 0)))
            for i, t1 in enumerate(market_trades):
                if t1.get("side", "").upper() != "BUY":
                    continue
                buy_price = float(t1.get("price", 0))
                buy_ts = float(t1.get("timestamp", 0))
                if buy_price <= 0:
                    continue
                for t2 in market_trades[i + 1:]:
                    if t2.get("side", "").upper() != "SELL":
                        continue
                    sell_price = float(t2.get("price", 0))
                    sell_ts = float(t2.get("timestamp", 0))
                    if sell_price <= 0:
                        continue
                    total_pairs += 1
                    time_gap_min = (sell_ts - buy_ts) / 60.0
                    price_diff_pct = abs(sell_price - buy_price) / buy_price
                    if time_gap_min <= 30 and price_diff_pct < 0.03:
                        wash_count += 1
                    break  # Only match first SELL after each BUY

        if total_pairs >= 3 and (wash_count / total_pairs) > MAX_WASH_RATIO:
            return "wash"

        # ── Bitcoin Focus: only keep wallets that primarily trade BTC ──
        # A wallet winning $8k on sports but losing $2k on BTC is useless to us
        # Check ALL wallets regardless of trade count (even 1 trade)
        if self.scorer and len(trades) >= 1:
            btc_count = sum(1 for t in trades
                            if self.scorer.is_bitcoin_market(t.get("title", "")))
            btc_ratio = btc_count / len(trades)
            if btc_ratio < MIN_BTC_RATIO:
                return "non_btc"

        return "active"

    # ── Network Discovery ("copy who they copy") ────────────

    def discover_network(self):
        """Find profitable traders in the same markets as our tracked traders.

        When a tracked trader makes a trade on a market, we look at who else
        is trading that same market. If they're profitable, we add them too.
        This is the 'copy whoever they are copying' feature.
        """
        now = time.time()
        if now - self._last_network_scan < NETWORK_DISCOVERY_INTERVAL:
            return

        if not self._hot_markets:
            self._last_network_scan = now
            return

        # Pick up to 3 hot markets to scan
        markets_to_scan = list(self._hot_markets.keys())[-3:]

        discovered = 0
        for condition_id in markets_to_scan:
            try:
                resp = self._session.get(
                    f"{DATA_API}/trades",
                    params={
                        "market": condition_id,
                        "limit": 50,
                    },
                    timeout=15,
                )
                resp.raise_for_status()
                trades = resp.json()
            except Exception:
                continue

            if not isinstance(trades, list):
                continue

            # Collect unique wallets from these trades
            candidate_wallets = set()
            for trade in trades:
                wallet = trade.get("maker", "") or trade.get("taker", "")
                if wallet and wallet not in self.tracked_wallets and wallet not in self.network_wallets:
                    candidate_wallets.add(wallet)

            # Check each candidate's profile on leaderboard
            for wallet in list(candidate_wallets)[:10]:  # Cap per market
                profile = self._check_wallet_pnl(wallet)
                if not profile:
                    time.sleep(0.3)
                    continue

                pnl = float(profile.get("pnl", 0))
                vol = float(profile.get("vol", 0))

                # Must be profitable + active volume + good efficiency
                if pnl < NETWORK_DISCOVERY_MIN_PNL:
                    time.sleep(0.3)
                    continue
                if vol < MIN_VOLUME:
                    time.sleep(0.3)
                    continue

                # Recency check
                seed_result = self._seed_history(wallet)
                if seed_result != "active":
                    time.sleep(0.3)
                    continue

                self.network_wallets[wallet] = {
                    "proxy_wallet": wallet,
                    "username": profile.get("userName", ""),
                    "pnl": pnl,
                    "volume": vol,
                    "rank": profile.get("rank", "?"),
                    "source": "network",
                    "discovered_via": condition_id[:12],
                    "last_poll": 0,
                    "trades_copied": 0,
                }
                discovered += 1

                if len(self.network_wallets) >= 200:
                    break

                time.sleep(0.3)

            if len(self.network_wallets) >= 200:
                break

        self._last_network_scan = now
        self._discovery_stats["network"] = len(self.network_wallets)

        if discovered:
            self._save_state()
            print(f"[WHALE] Network discovery: found {discovered} new traders "
                  f"({len(self.network_wallets)} network wallets total)")

    def _check_wallet_pnl(self, wallet):
        """Check a wallet's PnL via the leaderboard search."""
        try:
            resp = self._session.get(
                f"{DATA_API}/v1/leaderboard",
                params={
                    "timePeriod": "MONTH",
                    "proxyWallet": wallet,
                    "limit": 1,
                },
                timeout=10,
            )
            resp.raise_for_status()
            data = resp.json()
            if isinstance(data, list) and data:
                return data[0]
        except Exception:
            pass
        return None

    # ── Activity Polling ──────────────────────────────────────

    def poll_whale_activity(self):
        """Check one tracked wallet for new trades. Returns copy signals.

        Polls one wallet per call (round-robin) across both leaderboard
        and network pools. With 300+ wallets at 2s intervals, full
        rotation takes ~10 minutes.
        """
        signals = []
        now = time.time()

        # Merge both pools for polling
        all_wallets = {}
        all_wallets.update(self.network_wallets)
        all_wallets.update(self.tracked_wallets)  # Leaderboard gets priority

        # Find the wallet most overdue for polling
        wallet_to_poll = None
        oldest_poll = now
        for wallet, info in all_wallets.items():
            last = info.get("last_poll", 0)
            if now - last >= ACTIVITY_POLL_INTERVAL and last < oldest_poll:
                oldest_poll = last
                wallet_to_poll = wallet

        if not wallet_to_poll:
            return signals

        # Determine which pool this wallet belongs to
        if wallet_to_poll in self.tracked_wallets:
            info = self.tracked_wallets[wallet_to_poll]
        else:
            info = self.network_wallets[wallet_to_poll]

        try:
            trades = self._fetch_recent_activity(wallet_to_poll)
            info["last_poll"] = now

            for trade in trades:
                tx_hash = trade.get("transactionHash", "")
                if not tx_hash or tx_hash in self._seen_tx_hashes:
                    continue

                self._seen_tx_hashes.add(tx_hash)

                # Track which markets our traders are active in (for network discovery)
                cid = trade.get("conditionId", "")
                if cid:
                    if cid not in self._hot_markets:
                        self._hot_markets[cid] = set()
                    self._hot_markets[cid].add(wallet_to_poll)

                side = trade.get("side", "").upper()
                size = float(trade.get("size", 0))
                price = float(trade.get("price", 0))
                usdc_size = float(trade.get("usdcSize", 0)) or (size * price)

                # SELL signals → copy exit (close our position too)
                if side == "SELL":
                    if usdc_size >= MIN_TRADE_SIZE_USDC:
                        src_tag = "NET" if info.get("source") == "network" else "LB"
                        print(f"[WHALE] EXIT [{src_tag}]: {info.get('username', wallet_to_poll[:8])} "
                              f"SELL {trade.get('outcome', '?')} "
                              f"${usdc_size:.0f} on \"{trade.get('title', '?')[:40]}\"")

                        exit_signal = {
                            "type": "COPY_EXIT",
                            "source_wallet": wallet_to_poll,
                            "source_username": info.get("username", "?"),
                            "source_rank": info.get("rank", "?"),
                            "source_pool": info.get("source", "leaderboard"),
                            "condition_id": cid,
                            "token_id": trade.get("asset", ""),
                            "outcome": trade.get("outcome", ""),
                            "whale_price": price,
                            "whale_size": size,
                            "usdc_value": round(usdc_size, 2),
                            "market_title": trade.get("title", ""),
                            "tx_hash": tx_hash,
                            "timestamp": trade.get("timestamp", now),
                            "detected_at": now,
                        }
                        signals.append(exit_signal)
                    continue

                if side != "BUY":
                    continue

                # Filter by trade size
                if usdc_size < MIN_TRADE_SIZE_USDC:
                    continue

                # Price quality filter: skip entries with terrible risk/reward
                # Buying at $0.92 means risking $0.92 to make $0.08 (11:1 against)
                if price > 0.90:
                    continue

                # Market filter: Bitcoin Up or Down only — everything else is noise
                market_title = trade.get("title", "")
                if self.scorer and not self.scorer.is_bitcoin_market(market_title):
                    self._slow_skips += 1
                    continue

                # Consensus boost: count how many tracked wallets trade this market
                market_traders = len(self._hot_markets.get(cid, set()))

                # ── Signal scoring ──
                # Higher score = higher confidence = bigger copy size
                score = 0
                # Base: every signal starts at 1
                score += 1
                # Consensus: +1 per additional wallet trading same market
                score += min(market_traders - 1, 3)  # Cap at +3
                # Price quality: lower entry = better risk/reward
                if price <= 0.30:
                    score += 2    # Great odds (risk $0.30 to win $0.70)
                elif price <= 0.50:
                    score += 1    # Good odds
                # Whale PnL ranking: top-ranked wallets get a boost
                try:
                    rank = int(info.get("rank", 999))
                    if rank <= 50:
                        score += 1
                except (ValueError, TypeError):
                    pass

                signal = {
                    "type": "COPY_TRADE",
                    "source_wallet": wallet_to_poll,
                    "source_username": info.get("username", "?"),
                    "source_rank": info.get("rank", "?"),
                    "source_pool": info.get("source", "leaderboard"),
                    "source_pnl": info.get("pnl", 0),
                    "condition_id": cid,
                    "token_id": trade.get("asset", ""),
                    "side": side,
                    "outcome": trade.get("outcome", ""),
                    "outcome_index": trade.get("outcomeIndex", 0),
                    "whale_price": price,
                    "whale_size": size,
                    "usdc_value": round(usdc_size, 2),
                    "market_title": trade.get("title", ""),
                    "market_slug": trade.get("slug", ""),
                    "tx_hash": tx_hash,
                    "timestamp": trade.get("timestamp", now),
                    "detected_at": now,
                    "consensus": market_traders,
                    "score": score,
                }

                signals.append(signal)
                info["trades_copied"] = info.get("trades_copied", 0) + 1

                src_tag = "NET" if info.get("source") == "network" else "LB"
                print(f"[WHALE] SIGNAL [{src_tag}]: {info.get('username', wallet_to_poll[:8])} "
                      f"BUY {trade.get('outcome', '?')} @{price:.2f} "
                      f"${usdc_size:.0f} on \"{trade.get('title', '?')[:40]}\" "
                      f"(score={score}, consensus={market_traders})")

        except Exception:
            self._poll_errors += 1

        if signals:
            self.recent_signals.extend(signals)
            self.recent_signals = self.recent_signals[-500:]
            self._save_state()

        return signals

    def _fetch_recent_activity(self, wallet, limit=None):
        """Fetch recent trade activity for a wallet via Data API."""
        if limit is None:
            limit = SEED_HISTORY_LIMIT
        try:
            resp = self._session.get(
                f"{DATA_API}/activity",
                params={
                    "user": wallet,
                    "type": "TRADE",
                    "limit": limit,
                    "sortBy": "TIMESTAMP",
                    "sortDirection": "DESC",
                },
                timeout=10,
            )
            resp.raise_for_status()
            data = resp.json()
            return data if isinstance(data, list) else []
        except Exception:
            self._poll_errors += 1
            return []

    # ── Queries (for web UI and status) ───────────────────────

    def get_tracked_wallets(self):
        """Return all tracked wallets (both leaderboard and network)."""
        wallets = []

        for wallet, info in self.tracked_wallets.items():
            wallets.append({
                "wallet": wallet[:8] + "..." + wallet[-4:],
                "full_wallet": wallet,
                "username": info.get("username", ""),
                "rank": info.get("rank", "?"),
                "pnl": info.get("pnl", 0),
                "volume": info.get("volume", 0),
                "trades_copied": info.get("trades_copied", 0),
                "source": "leaderboard",
            })

        for wallet, info in self.network_wallets.items():
            wallets.append({
                "wallet": wallet[:8] + "..." + wallet[-4:],
                "full_wallet": wallet,
                "username": info.get("username", ""),
                "rank": info.get("rank", "?"),
                "pnl": info.get("pnl", 0),
                "volume": info.get("volume", 0),
                "trades_copied": info.get("trades_copied", 0),
                "source": "network",
            })

        wallets.sort(key=lambda w: float(w.get("pnl", 0)), reverse=True)
        return wallets

    def get_recent_signals(self, limit=20):
        return list(reversed(self.recent_signals[-limit:]))

    def get_stats(self):
        total = len(self.tracked_wallets) + len(self.network_wallets)
        return {
            "tracked_wallets": total,
            "leaderboard_wallets": len(self.tracked_wallets),
            "network_wallets": len(self.network_wallets),
            "total_signals": len(self.recent_signals),
            "seen_transactions": len(self._seen_tx_hashes),
            "hot_markets": len(self._hot_markets),
            "poll_errors": self._poll_errors,
            "slow_markets_skipped": self._slow_skips,
            "discovery": self._discovery_stats,
        }


--- FILE: run.py ---
import time
import sys
from src.config import load_or_create_config
from src.bot import TradingBot

def main():
    print("--- Polymarket Bot v0.1 (Spec Implementation) ---")

    # 1. Load Config (Prompts user if needed) - Spec 6.1
    config = load_or_create_config()
    print("[*] Config loaded.")

    # 2. Initialize Bot - Spec 7.1
    bot = TradingBot(config)

    # 3. Start Web UI (daemon thread — dies with main)
    from src.web_server import start_web_server
    port = config.get("WEB_PORT", 8080)
    start_web_server(config, bot)
    print(f"[*] Web UI running at http://localhost:{port}")

    # 4. Start Loop - Spec 7.2
    print("[*] Starting main loop (Press Ctrl+C to stop)...")
    try:
        bot.run()
    except KeyboardInterrupt:
        print("\n[!] Manual Stop triggered.")
        bot.shutdown()
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Critical Error: {e}")
        bot.shutdown()
        sys.exit(1)

if __name__ == "__main__":
    main()


--- FILE: backtest.py ---
"""Backtest runner — replay collected data against strategy variants.

Usage:
    python3 backtest.py                    # Use latest snapshot, default strategies
    python3 backtest.py --file session.jsonl  # Use specific snapshot file
    python3 backtest.py --export           # Save results as JSON for LLM review
"""

import sys
import os
import json
import time

from src.data_collector import list_snapshot_files
from src.backtester import Backtester


# Strategy variants to test
DEFAULT_STRATEGIES = [
    {
        "name": "Conservative",
        "MIN_PROFIT": 0.02,
        "COST_BUFFER": 0.01,
        "MIN_LIQUIDITY": 5.0,
        "MAX_ORDER_SIZE": 10.0,
    },
    {
        "name": "Balanced",
        "MIN_PROFIT": 0.015,
        "COST_BUFFER": 0.005,
        "MIN_LIQUIDITY": 2.0,
        "MAX_ORDER_SIZE": 15.0,
    },
    {
        "name": "Aggressive",
        "MIN_PROFIT": 0.005,
        "COST_BUFFER": 0.003,
        "MIN_LIQUIDITY": 1.0,
        "MAX_ORDER_SIZE": 25.0,
    },
    {
        "name": "Micro-Profit",
        "MIN_PROFIT": 0.001,
        "COST_BUFFER": 0.001,
        "MIN_LIQUIDITY": 0.5,
        "MAX_ORDER_SIZE": 50.0,
    },
]


def main():
    print("=" * 60)
    print("  POLYMARKET BACKTESTER")
    print("  Replay collected data against strategy variants")
    print("=" * 60)

    # Parse args
    export_mode = "--export" in sys.argv
    specific_file = None
    if "--file" in sys.argv:
        idx = sys.argv.index("--file")
        if idx + 1 < len(sys.argv):
            specific_file = sys.argv[idx + 1]

    # Find snapshot file
    if specific_file:
        if not os.path.exists(specific_file):
            # Try in snapshots dir
            specific_file = os.path.join("data/snapshots", specific_file)
        if not os.path.exists(specific_file):
            print(f"[!] File not found: {specific_file}")
            sys.exit(1)
        snapshot_file = specific_file
    else:
        files = list_snapshot_files()
        if not files:
            print("[!] No snapshot files found in data/snapshots/")
            print("[*] Run the bot first to collect data:")
            print("    python3 run.py")
            print("[*] The bot records order book snapshots as it runs.")
            print("[*] Let it run for a few hours, then come back and run this.")
            sys.exit(1)

        # Use the largest file (most data)
        files.sort(key=lambda f: f["snapshots"], reverse=True)
        snapshot_file = files[0]["path"]
        print(f"\nAvailable snapshot files:")
        for f in files:
            marker = " <-- using this" if f["path"] == snapshot_file else ""
            print(f"  {f['filename']}: {f['snapshots']} snapshots, "
                  f"{f['size_kb']}KB{marker}")

    print(f"\n[*] Loading: {snapshot_file}")

    # Run backtest
    bt = Backtester(snapshot_file)

    if len(bt.snapshots) < 10:
        print(f"[!] Only {len(bt.snapshots)} snapshots — need more data.")
        print("[*] Let the bot run longer to collect more order book data.")
        sys.exit(1)

    print(f"\n[*] Testing {len(DEFAULT_STRATEGIES)} strategy variants...\n")
    results = bt.compare_strategies(DEFAULT_STRATEGIES)

    # Print report
    report = bt.generate_report(results)
    print("\n" + report)

    # Export
    if export_mode:
        export_data = bt.export_for_llm(results)
        export_path = f"data/backtest_results_{int(time.time())}.json"
        os.makedirs("data", exist_ok=True)
        with open(export_path, "w") as f:
            json.dump(export_data, f, indent=2)
        print(f"\n[*] Results exported to: {export_path}")
        print("[*] You can paste this file into ChatGPT/Claude for analysis.")
    else:
        print("\nTip: Run with --export to save results as JSON for LLM review")


if __name__ == "__main__":
    main()


================================================================================
SECTION: CONFIGURATION (secrets redacted)
================================================================================
{
  "_config_version": 9,
  "MIN_PROFIT": 0.003,
  "COST_BUFFER": 0.002,
  "MIN_LIQUIDITY": 0.5,
  "MAX_ORDER_SIZE": 3.0,
  "MARKETS_PER_CYCLE": 20,
  "FETCH_WORKERS": 4,
  "COPY_TRADE_SIZE": 2.0,
  "COPY_RATIO": 0.01,
  "COPY_MIN_SIZE": 0.5,
  "COPY_MAX_SIZE": 5.0,
  "COPY_MAX_PER_MARKET": 10.0,
  "MAX_EXPOSURE": 25.0,
  "MAX_DAILY_LOSS": 15.0,
  "MODE": "PAPER",
  "POLY_API_KEY": "paper-mode",
  "POLY_SECRET": "paper-mode",
  "POLY_PASSPHRASE": "paper-mode",
  "PAPER_BALANCE": 50.0,
  "WEB_PORT": 8080,
  "COLLECT_DATA": true,
  "INFRA_TIER": 1,
  "DASHBOARD_TOKEN": "REDACTED",
  "DASHBOARD_BIND": "127.0.0.1",
  "TAKE_PROFIT_PCT": 0.15,
  "STOP_LOSS_PCT": 0.25,
  "RISK_PER_TRADE_PCT": 0.01,
  "RISK_MAX_TRADE_PCT": 0.03,
  "RISK_MAX_MARKET_PCT": 0.06,
  "RISK_MAX_EXPOSURE_PCT": 0.5,
  "RISK_MAX_DAILY_LOSS_PCT": 0.3
}

================================================================================
SECTION: PAPER TRADING STATE
================================================================================
{
  "version": 3,
  "starting_balance": 50.0,
  "cash_balance": 54.56456972156322,
  "total_trades": 15,
  "winning_trades": 8,
  "losing_trades": 2,
  "total_fees_paid": 0.8363381575829225,
  "total_realized_pnl": 4.5647317215632075,
  "total_opportunities_seen": 0,
  "total_scans": 0,
  "created_at": 1770575071.8735821,
  "last_updated": 1770581542.59962,
  "positions": {
    "copy_0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2_DOWN": {
      "position_id": "5349b4fe",
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "outcome": "DOWN",
      "size": 17.62,
      "avg_price": 0.0328,
      "total_cost": 0.5903,
      "total_fees": 0.0115,
      "opened_at": 1770575975.475737,
      "status": "CLOSED_TAKE_PROFIT",
      "settlement_value": 3.3755,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770575985.664911,
      "sell_price": 0.1959,
      "realized_pnl": 2.7852
    },
    "copy_0x5b0c1a6e9fabf2cea14de8951a7173c3624bea73ca4585aac0baf0f08788db78_DOWN": {
      "position_id": "334d35f3",
      "condition_id": "0x5b0c1a6e9fabf2cea14de8951a7173c3624bea73ca4585aac0baf0f08788db78",
      "market_name": "Bitcoin Up or Down - February 8, 1:45PM-",
      "token_id": "69296638964405703754473629082760161141186832483007945639467265489657637413733",
      "outcome": "DOWN",
      "size": 5.119206484568876,
      "avg_price": 0.5323,
      "total_cost": 2.7944380000000004,
      "total_fees": 0.054538,
      "opened_at": 1770576268.475925,
      "status": "CLOSED_EXIT",
      "settlement_value": 2.4573,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770576467.682146,
      "sell_price": 0.4903,
      "realized_pnl": -0.3371
    },
    "copy_0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4_DOWN": {
      "position_id": "62a1896d",
      "condition_id": "0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4",
      "market_name": "Bitcoin Up or Down - February 8, 2:00PM-",
      "token_id": "46698823012595131551182242301279384898618398373522028982776419493026486417371",
      "outcome": "DOWN",
      "size": 9.07,
      "avg_price": 0.1151,
      "total_cost": 1.0713,
      "total_fees": 0.0209,
      "opened_at": 1770578078.6146271,
      "status": "CLOSED_TAKE_PROFIT",
      "settlement_value": 2.1281,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770578080.4884229,
      "sell_price": 0.2397,
      "realized_pnl": 1.0568
    },
    "copy_0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba_UP": {
      "position_id": "79dcb1af",
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "106876650817639706597841203256525536562508513428040218465959526046660613900167",
      "outcome": "UP",
      "size": 3.4,
      "avg_price": 0.4854,
      "total_cost": 1.685,
      "total_fees": 0.033,
      "opened_at": 1770579389.746439,
      "status": "CLOSED_TAKE_PROFIT",
      "settlement_value": 1.9692,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "source_wallet": "0x13a0aec70f0f11f12a2346455c8072245754012d",
      "closed_at": 1770579391.6829581,
      "sell_price": 0.5929,
      "realized_pnl": 0.2842
    },
    "copy_0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba_DOWN": {
      "position_id": "25e9ef0e",
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "61259157125723532891619682835755052574956047094740152712516361120401935393804",
      "outcome": "DOWN",
      "size": 4.97,
      "avg_price": 0.2371,
      "total_cost": 1.2048,
      "total_fees": 0.0236,
      "opened_at": 1770579641.053451,
      "status": "CLOSED_TAKE_PROFIT",
      "settlement_value": 2.2608,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770579642.9786072,
      "sell_price": 0.4649,
      "realized_pnl": 1.056
    },
    "copy_0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693_DOWN": {
      "position_id": "a627a17d",
      "condition_id": "0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693",
      "market_name": "Bitcoin Up or Down - February 8, 2:45PM-",
      "token_id": "59601673913475707314327856674610487498346941767521304954788084819423437290219",
      "outcome": "DOWN",
      "size": 5.752930519807035,
      "avg_price": 0.5503,
      "total_cost": 3.238834,
      "total_fees": 0.063234,
      "opened_at": 1770579954.9686852,
      "status": "CLOSED_STOP_LOSS",
      "settlement_value": 0.8313,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770580381.347231,
      "sell_price": 0.1485,
      "realized_pnl": -2.4075
    },
    "copy_0x8538e2214fb0578cdf9656c4e242fa3712334373910d41ef3f7a6671ad43f5a6_DOWN": {
      "position_id": "c2a8337f",
      "condition_id": "0x8538e2214fb0578cdf9656c4e242fa3712334373910d41ef3f7a6671ad43f5a6",
      "market_name": "Bitcoin Up or Down - February 8, 3:00PM-",
      "token_id": "27375031758190270851741886155738910010624763646529975880562710745930831772741",
      "outcome": "DOWN",
      "size": 2.56,
      "avg_price": 0.5605,
      "total_cost": 1.4685,
      "total_fees": 0.0287,
      "opened_at": 1770580870.253505,
      "status": "CLOSED_TAKE_PROFIT",
      "settlement_value": 2.0862,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "source_wallet": "0x477a7d28ed844984088129207c0afcb2459e2d8e",
      "closed_at": 1770581282.488458,
      "sell_price": 0.8328,
      "realized_pnl": 0.6177
    }
  },
  "trade_history": [
    {
      "fill_id": "7777b5da",
      "timestamp": 1770575312.74564,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.5415,
      "size": 0.92,
      "fee": 0.01,
      "fee_rate_bps": 200,
      "slippage": 0.0215,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "score": 1
    },
    {
      "fill_id": "b24f77ce",
      "timestamp": 1770575520.4218519,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.336,
      "size": 1.47,
      "fee": 0.0099,
      "fee_rate_bps": 200,
      "slippage": 0.016,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "score": 2
    },
    {
      "fill_id": "a992d5f8",
      "timestamp": 1770575520.471614,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.344,
      "size": 1.81,
      "fee": 0.0125,
      "fee_rate_bps": 200,
      "slippage": 0.024,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "score": 2
    },
    {
      "fill_id": "f8089ba2",
      "timestamp": 1770575522.381588,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.4924,
      "size": 4.21,
      "fee": 0.0414,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 0.3653
    },
    {
      "fill_id": "ba63e5f4",
      "timestamp": 1770575832.693444,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.0922,
      "size": 10.48,
      "fee": 0.0193,
      "fee_rate_bps": 200,
      "slippage": 0.004,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "score": 3
    },
    {
      "fill_id": "56c25f7f",
      "timestamp": 1770575834.5516632,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.1971,
      "size": 10.48,
      "fee": 0.0413,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 1.0268
    },
    {
      "fill_id": "559e5679",
      "timestamp": 1770575975.475737,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.0328,
      "size": 17.62,
      "fee": 0.0115,
      "fee_rate_bps": 200,
      "slippage": 0.0028,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 4
    },
    {
      "fill_id": "b99c242e",
      "timestamp": 1770575985.664911,
      "condition_id": "0x501578d67fec79dd02212dea422010ac5742cccdece916aae4dd9575ce8394a2",
      "market_name": "Bitcoin Up or Down - February 8, 1:30PM-",
      "token_id": "113939227670671056692827238312852490654604468483176685258920854264509932288414",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.1959,
      "size": 17.62,
      "fee": 0.069,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 2.7852
    },
    {
      "fill_id": "e2d36b0c",
      "timestamp": 1770576268.475925,
      "condition_id": "0x5b0c1a6e9fabf2cea14de8951a7173c3624bea73ca4585aac0baf0f08788db78",
      "market_name": "Bitcoin Up or Down - February 8, 1:45PM-",
      "token_id": "69296638964405703754473629082760161141186832483007945639467265489657637413733",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.586,
      "size": 2.77,
      "fee": 0.0325,
      "fee_rate_bps": 200,
      "slippage": 0.036,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 1
    },
    {
      "fill_id": "04b52445",
      "timestamp": 1770576368.171647,
      "condition_id": "0x5b0c1a6e9fabf2cea14de8951a7173c3624bea73ca4585aac0baf0f08788db78",
      "market_name": "Bitcoin Up or Down - February 8, 1:45PM-",
      "token_id": "69296638964405703754473629082760161141186832483007945639467265489657637413733",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.4691,
      "size": 2.35,
      "fee": 0.022,
      "fee_rate_bps": 200,
      "slippage": 0.0291,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 2
    },
    {
      "fill_id": "675f2800",
      "timestamp": 1770576467.695585,
      "condition_id": "0x5b0c1a6e9fabf2cea14de8951a7173c3624bea73ca4585aac0baf0f08788db78",
      "market_name": "Bitcoin Up or Down - February 8, 1:45PM-",
      "token_id": "69296638964405703754473629082760161141186832483007945639467265489657637413733",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.4903,
      "size": 5.12,
      "fee": 0.0502,
      "fee_rate_bps": 200,
      "slippage": 0.0297,
      "trade_type": "COPY_EXIT",
      "source_username": "Bot9735",
      "realized_pnl": -0.3371
    },
    {
      "fill_id": "440294dd",
      "timestamp": 1770577974.7968168,
      "condition_id": "0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4",
      "market_name": "Bitcoin Up or Down - February 8, 2:00PM-",
      "token_id": "46698823012595131551182242301279384898618398373522028982776419493026486417371",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.2106,
      "size": 6.27,
      "fee": 0.0264,
      "fee_rate_bps": 200,
      "slippage": 0.0106,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 3
    },
    {
      "fill_id": "1c079b62",
      "timestamp": 1770577976.6939259,
      "condition_id": "0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4",
      "market_name": "Bitcoin Up or Down - February 8, 2:00PM-",
      "token_id": "46698823012595131551182242301279384898618398373522028982776419493026486417371",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.2395,
      "size": 6.27,
      "fee": 0.03,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 0.1174
    },
    {
      "fill_id": "d4eae8f7",
      "timestamp": 1770578078.6146271,
      "condition_id": "0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4",
      "market_name": "Bitcoin Up or Down - February 8, 2:00PM-",
      "token_id": "46698823012595131551182242301279384898618398373522028982776419493026486417371",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.1151,
      "size": 9.07,
      "fee": 0.0209,
      "fee_rate_bps": 200,
      "slippage": 0.0051,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 3
    },
    {
      "fill_id": "10bde8bd",
      "timestamp": 1770578080.4884229,
      "condition_id": "0x711e0947890c731557fac7e42836c813e1182e5d1eb3953df06fbead677895b4",
      "market_name": "Bitcoin Up or Down - February 8, 2:00PM-",
      "token_id": "46698823012595131551182242301279384898618398373522028982776419493026486417371",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.2397,
      "size": 9.07,
      "fee": 0.0435,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 1.0568
    },
    {
      "fill_id": "220394fe",
      "timestamp": 1770579389.746439,
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "106876650817639706597841203256525536562508513428040218465959526046660613900167",
      "side": "UP",
      "direction": "BUY",
      "price": 0.4854,
      "size": 3.4,
      "fee": 0.033,
      "fee_rate_bps": 200,
      "slippage": 0.0254,
      "trade_type": "COPY",
      "source_username": "Trik7895",
      "score": 3
    },
    {
      "fill_id": "de3660c4",
      "timestamp": 1770579391.6829581,
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "106876650817639706597841203256525536562508513428040218465959526046660613900167",
      "side": "UP",
      "direction": "SELL",
      "price": 0.5929,
      "size": 3.4,
      "fee": 0.0403,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 0.2842
    },
    {
      "fill_id": "8191a1ea",
      "timestamp": 1770579641.053451,
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "61259157125723532891619682835755052574956047094740152712516361120401935393804",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.2371,
      "size": 4.97,
      "fee": 0.0236,
      "fee_rate_bps": 200,
      "slippage": 0.0142,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 5
    },
    {
      "fill_id": "da01a545",
      "timestamp": 1770579642.9786072,
      "condition_id": "0x7a1c3b9188046b7075db75bf3dac577980804d393398ac3b3f1ed26775b2c0ba",
      "market_name": "Bitcoin Up or Down - February 8, 2:30PM-",
      "token_id": "61259157125723532891619682835755052574956047094740152712516361120401935393804",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.4649,
      "size": 4.97,
      "fee": 0.0462,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 1.056
    },
    {
      "fill_id": "5ef04cde",
      "timestamp": 1770579954.9686852,
      "condition_id": "0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693",
      "market_name": "Bitcoin Up or Down - February 8, 2:45PM-",
      "token_id": "59601673913475707314327856674610487498346941767521304954788084819423437290219",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.5408,
      "size": 1.69,
      "fee": 0.0182,
      "fee_rate_bps": 200,
      "slippage": 0.0208,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 2
    },
    {
      "fill_id": "dbc275be",
      "timestamp": 1770579955.0487008,
      "condition_id": "0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693",
      "market_name": "Bitcoin Up or Down - February 8, 2:45PM-",
      "token_id": "59601673913475707314327856674610487498346941767521304954788084819423437290219",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.5501,
      "size": 3.02,
      "fee": 0.0333,
      "fee_rate_bps": 200,
      "slippage": 0.0301,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 2
    },
    {
      "fill_id": "cfa15c1f",
      "timestamp": 1770579955.124973,
      "condition_id": "0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693",
      "market_name": "Bitcoin Up or Down - February 8, 2:45PM-",
      "token_id": "59601673913475707314327856674610487498346941767521304954788084819423437290219",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.566,
      "size": 1.04,
      "fee": 0.0118,
      "fee_rate_bps": 200,
      "slippage": 0.036,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 2
    },
    {
      "fill_id": "9294bfae",
      "timestamp": 1770580381.347231,
      "condition_id": "0x8626ad3fed7f3e1b8eb6bcf707b60dd0bbf7913efaa994d60e62aa930d70d693",
      "market_name": "Bitcoin Up or Down - February 8, 2:45PM-",
      "token_id": "59601673913475707314327856674610487498346941767521304954788084819423437290219",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.1485,
      "size": 5.75,
      "fee": 0.0171,
      "fee_rate_bps": 200,
      "trade_type": "STOP_LOSS",
      "realized_pnl": -2.4075
    },
    {
      "fill_id": "a03c5131",
      "timestamp": 1770580870.253505,
      "condition_id": "0x8538e2214fb0578cdf9656c4e242fa3712334373910d41ef3f7a6671ad43f5a6",
      "market_name": "Bitcoin Up or Down - February 8, 3:00PM-",
      "token_id": "27375031758190270851741886155738910010624763646529975880562710745930831772741",
      "side": "DOWN",
      "direction": "BUY",
      "price": 0.5605,
      "size": 2.56,
      "fee": 0.0287,
      "fee_rate_bps": 200,
      "slippage": 0.0205,
      "trade_type": "COPY",
      "source_username": "Bot9735",
      "score": 2
    },
    {
      "fill_id": "ca942f45",
      "timestamp": 1770581282.488458,
      "condition_id": "0x8538e2214fb0578cdf9656c4e242fa3712334373910d41ef3f7a6671ad43f5a6",
      "market_name": "Bitcoin Up or Down - February 8, 3:00PM-",
      "token_id": "27375031758190270851741886155738910010624763646529975880562710745930831772741",
      "side": "DOWN",
      "direction": "SELL",
      "price": 0.8328,
      "size": 2.56,
      "fee": 0.0426,
      "fee_rate_bps": 200,
      "trade_type": "TAKE_PROFIT",
      "realized_pnl": 0.6177
    }
  ],
  "pnl_snapshots": [
    {
      "timestamp": 1770575215.7847302,
      "cash_balance": 50.0,
      "unrealized_pnl": 0.0,
      "total_value": 50.0,
      "positions_count": 0
    },
    {
      "timestamp": 1770575278.368295,
      "cash_balance": 50.0,
      "unrealized_pnl": 0.0,
      "total_value": 50.0,
      "positions_count": 0
    },
    {
      "timestamp": 1770575339.966979,
      "cash_balance": 49.48,
      "unrealized_pnl": -0.06,
      "total_value": 49.43,
      "positions_count": 1
    },
    {
      "timestamp": 1770575400.701011,
      "cash_balance": 49.48,
      "unrealized_pnl": -0.06,
      "total_value": 49.43,
      "positions_count": 1
    },
    {
      "timestamp": 1770575462.24912,
      "cash_balance": 49.48,
      "unrealized_pnl": -0.06,
      "total_value": 49.43,
      "positions_count": 1
    },
    {
      "timestamp": 1770575522.3939729,
      "cash_balance": 50.37,
      "unrealized_pnl": 0.0,
      "total_value": 50.37,
      "positions_count": 0
    },
    {
      "timestamp": 1770575585.608475,
      "cash_balance": 50.37,
      "unrealized_pnl": 0.0,
      "total_value": 50.37,
      "positions_count": 0
    },
    {
      "timestamp": 1770575646.521268,
      "cash_balance": 50.37,
      "unrealized_pnl": 0.0,
      "total_value": 50.37,
      "positions_count": 0
    },
    {
      "timestamp": 1770575709.19145,
      "cash_balance": 50.37,
      "unrealized_pnl": 0.0,
      "total_value": 50.37,
      "positions_count": 0
    },
    {
      "timestamp": 1770575772.0585191,
      "cash_balance": 50.37,
      "unrealized_pnl": 0.0,
      "total_value": 50.37,
      "positions_count": 0
    },
    {
      "timestamp": 1770575834.5680819,
      "cash_balance": 51.39,
      "unrealized_pnl": 0.0,
      "total_value": 51.39,
      "positions_count": 0
    },
    {
      "timestamp": 1770575895.353699,
      "cash_balance": 51.39,
      "unrealized_pnl": 0.0,
      "total_value": 51.39,
      "positions_count": 0
    },
    {
      "timestamp": 1770575957.154401,
      "cash_balance": 51.39,
      "unrealized_pnl": 0.0,
      "total_value": 51.39,
      "positions_count": 0
    },
    {
      "timestamp": 1770576017.32795,
      "cash_balance": 54.18,
      "unrealized_pnl": 0.0,
      "total_value": 54.18,
      "positions_count": 0
    },
    {
      "timestamp": 1770576079.1906,
      "cash_balance": 54.18,
      "unrealized_pnl": 0.0,
      "total_value": 54.18,
      "positions_count": 0
    },
    {
      "timestamp": 1770576139.6271338,
      "cash_balance": 54.18,
      "unrealized_pnl": 0.0,
      "total_value": 54.18,
      "positions_count": 0
    },
    {
      "timestamp": 1770576200.200948,
      "cash_balance": 54.18,
      "unrealized_pnl": 0.0,
      "total_value": 54.18,
      "positions_count": 0
    },
    {
      "timestamp": 1770576261.237779,
      "cash_balance": 54.18,
      "unrealized_pnl": 0.0,
      "total_value": 54.18,
      "positions_count": 0
    },
    {
      "timestamp": 1770576323.688174,
      "cash_balance": 52.51,
      "unrealized_pnl": -0.28,
      "total_value": 52.24,
      "positions_count": 1
    },
    {
      "timestamp": 1770576384.386865,
      "cash_balance": 51.38,
      "unrealized_pnl": -0.23,
      "total_value": 51.15,
      "positions_count": 1
    },
    {
      "timestamp": 1770576445.463142,
      "cash_balance": 51.38,
      "unrealized_pnl": -0.23,
      "total_value": 51.15,
      "positions_count": 1
    },
    {
      "timestamp": 1770576507.096609,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576567.418358,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576629.2189078,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576690.9527318,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576753.505526,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576814.10351,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576875.113631,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576935.383874,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770576997.16906,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577058.550412,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577119.423538,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577180.350629,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577240.741968,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577301.715263,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577364.065305,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577426.1694589,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577486.303575,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577549.238204,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577609.350063,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577672.188033,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577734.412708,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577796.880629,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577859.422514,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577922.447188,
      "cash_balance": 53.84,
      "unrealized_pnl": 0.0,
      "total_value": 53.84,
      "positions_count": 0
    },
    {
      "timestamp": 1770577982.800858,
      "cash_balance": 53.96,
      "unrealized_pnl": 0.0,
      "total_value": 53.96,
      "positions_count": 0
    },
    {
      "timestamp": 1770578043.227743,
      "cash_balance": 53.96,
      "unrealized_pnl": 0.0,
      "total_value": 53.96,
      "positions_count": 0
    },
    {
      "timestamp": 1770578104.24366,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578167.1793668,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578228.188714,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578288.5231628,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578349.808511,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578411.415228,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578472.360374,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578532.864588,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578593.145494,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578654.3550642,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578806.923413,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578868.094198,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578928.6234088,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770578990.8547509,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579051.655363,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579112.001009,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579172.197118,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579234.594837,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579297.1058,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579357.369611,
      "cash_balance": 55.01,
      "unrealized_pnl": 0.0,
      "total_value": 55.01,
      "positions_count": 0
    },
    {
      "timestamp": 1770579417.7680352,
      "cash_balance": 55.3,
      "unrealized_pnl": 0.0,
      "total_value": 55.3,
      "positions_count": 0
    },
    {
      "timestamp": 1770579480.397484,
      "cash_balance": 55.3,
      "unrealized_pnl": 0.0,
      "total_value": 55.3,
      "positions_count": 0
    },
    {
      "timestamp": 1770579542.353439,
      "cash_balance": 55.3,
      "unrealized_pnl": 0.0,
      "total_value": 55.3,
      "positions_count": 0
    },
    {
      "timestamp": 1770579603.335235,
      "cash_balance": 55.3,
      "unrealized_pnl": 0.0,
      "total_value": 55.3,
      "positions_count": 0
    },
    {
      "timestamp": 1770579663.932678,
      "cash_balance": 56.35,
      "unrealized_pnl": 0.0,
      "total_value": 56.35,
      "positions_count": 0
    },
    {
      "timestamp": 1770579725.63768,
      "cash_balance": 56.35,
      "unrealized_pnl": 0.0,
      "total_value": 56.35,
      "positions_count": 0
    },
    {
      "timestamp": 1770579785.669325,
      "cash_balance": 56.35,
      "unrealized_pnl": 0.0,
      "total_value": 56.35,
      "positions_count": 0
    },
    {
      "timestamp": 1770579846.4312682,
      "cash_balance": 56.35,
      "unrealized_pnl": 0.0,
      "total_value": 56.35,
      "positions_count": 0
    },
    {
      "timestamp": 1770579908.7845068,
      "cash_balance": 56.35,
      "unrealized_pnl": 0.0,
      "total_value": 56.35,
      "positions_count": 0
    },
    {
      "timestamp": 1770579968.950976,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580030.1170921,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580090.802788,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580153.596925,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580214.3657868,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580274.979135,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580337.3276732,
      "cash_balance": 53.12,
      "unrealized_pnl": -0.36,
      "total_value": 52.75,
      "positions_count": 1
    },
    {
      "timestamp": 1770580398.3236961,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580460.893944,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580521.228769,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580582.5973408,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580644.890516,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580705.531337,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580767.5746849,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580828.104052,
      "cash_balance": 53.95,
      "unrealized_pnl": 0.0,
      "total_value": 53.95,
      "positions_count": 0
    },
    {
      "timestamp": 1770580890.696026,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770580952.981932,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581014.530895,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581077.324964,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581137.8954508,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581200.2615528,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581262.600252,
      "cash_balance": 52.48,
      "unrealized_pnl": -0.19,
      "total_value": 52.29,
      "positions_count": 1
    },
    {
      "timestamp": 1770581325.394709,
      "cash_balance": 54.56,
      "unrealized_pnl": 0.0,
      "total_value": 54.56,
      "positions_count": 0
    },
    {
      "timestamp": 1770581386.150416,
      "cash_balance": 54.56,
      "unrealized_pnl": 0.0,
      "total_value": 54.56,
      "positions_count": 0
    },
    {
      "timestamp": 1770581448.4802759,
      "cash_balance": 54.56,
      "unrealized_pnl": 0.0,
      "total_value": 54.56,
      "positions_count": 0
    },
    {
      "timestamp": 1770581510.553366,
      "cash_balance": 54.56,
      "unrealized_pnl": 0.0,
      "total_value": 54.56,
      "positions_count": 0
    }
  ]
}

================================================================================
SECTION: WALLET SCORER DATA
================================================================================
{
  "total_wallets": 0,
  "wallets_with_trades": 0,
  "top_10_by_roi": []
}

================================================================================
SECTION: WHALE TRACKER STATE (summary)
================================================================================
{
  "tracked_wallets": 0,
  "total_seen_tx": 45331,
  "signal_count": 0,
  "last_signals": []
}

================================================================================
SECTION: DATA SNAPSHOTS (latest session stats)
================================================================================
Latest session file: session_1770575071.jsonl
Total snapshots recorded: 41968
First snapshot: {
  "ts": 1770575214.06,
  "cid": "0xb1d2cd56624ec8bb3d8115d50d503d0e8578bf32d754ad5fe3c0e08a73186c57",
  "yes_ask": 0.99,
  "no_ask": 0.99,
  "yes_bid": 0.01,
  "no_bid": 0.01,
  "yes_depth": [
    [
      0.99,
      73174.17
    ],
    [
      0.98,
      2554.54
    ],
    [
      0.97,
      500.0
    ],
    [
      0.96,
      7.73
    ],
    [
      0.95,
      51.52
    ]
  ],
  "no_depth": [
    [
      0.99,
      2500.0
    ],
    [
      0.98,
      2506.68
    ],
    [
      0.97,
      7005.0
    ],
    [
      0.96,
      2030.75
    ],
    [
      0.95,
      3000.0
    ]
  ],
  "yes_bid_depth": [
    [
      0.01,
      2500.0
    ],
    [
      0.02,
      2506.68
    ],
    [
      0.03,
      7005.0
    ],
    [
      0.04,
      2030.75
    ],
    [
      0.05,
      3000.0
    ]
  ],
  "no_bid_depth": [
    [
      0.01,
      73174.17
    ],
    [
      0.02,
      2554.54
    ],
    [
      0.03,
      500.0
    ],
    [
      0.04,
      7.73
    ],
    [
      0.05,
      51.52
    ]
  ],
  "spread": 0.98,
  "opp": null
}
Last snapshot: {
  "ts": 1770581530.6,
  "cid": "0xe109380d49786b25c8c20ca88bfbf5ffabbe0a91a25a9d8795312d5a9701f998",
  "yes_ask": 0.99,
  "no_ask": 0.96,
  "yes_bid": 0.04,
  "no_bid": 0.01,
  "yes_depth": [
    [
      0.99,
      510016.03
    ],
    [
      0.98,
      51000.0
    ],
    [
      0.97,
      9.48
    ],
    [
      0.96,
      2500.0
    ],
    [
      0.95,
      9030.0
    ]
  ],
  "no_depth": [
    [
      0.96,
      121.0
    ],
    [
      0.95,
      122.1
    ],
    [
      0.94,
      247.14
    ]
  ],
  "yes_bid_depth": [
    [
      0.04,
      121.0
    ],
    [
      0.05,
      122.1
    ],
    [
      0.06,
      247.14
    ]
  ],
  "no_bid_depth": [
    [
      0.01,
      510016.03
    ],
    [
      0.02,
      51000.0
    ],
    [
      0.03,
      9.48
    ],
    [
      0.04,
      2500.0
    ],
    [
      0.05,
      9030.0
    ]
  ],
  "spread": 0.95,
  "opp": null
}

================================================================================
SECTION: AUDIT LOG (last 100 entries)
================================================================================

2026-02-06T21:19:49.395456 | COPY_FILL | Copied 0x0ab3a090e76fdec44: BUY UP@0.770 x0.6 $0.56 score=1 wm=1.0 slip=8.4% gas=$0.008 [OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:15PM-"
2026-02-06T21:19:53.976234 | STOP_LOSS | UP@0.489 x0.7 PnL=$-0.28 (-50.1%) on "Bitcoin Up or Down - February 6, 4:15PM-"
2026-02-06T21:26:12.827843 | COPY_FILL | Copied a115: BUY UP@0.165 x8.3 $1.51 score=4 wm=1.0 slip=9.8% gas=$0.002 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 3:45PM-"
2026-02-06T21:26:14.622181 | PAPER_SETTLED | [COPY] 0x5a7cf295d4 resolved DOWN. Payout=$0.00 PnL=$-1.5111
2026-02-06T21:30:23.054227 | COPY_FILL | Copied 0x84b2b67922c9cd6de0d647d7cab60eab108b5e52: BUY DOWN@0.585 x0.9 $0.56 score=4 wm=1.0 slip=8.3% gas=$0.002 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:15PM-"
2026-02-06T21:30:24.803406 | STOP_LOSS | DOWN@0.010 x0.9 PnL=$-0.55 (-99.4%) on "Bitcoin Up or Down - February 6, 4:15PM-"
2026-02-06T21:50:14.765651 | COPY_FILL | Copied TeleBoba: BUY DOWN@0.515 x2.3 $1.31 score=2 wm=1.0 slip=7.4% gas=$0.002 [OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:15PM-"
2026-02-06T22:02:16.328718 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.936 x1.7 $1.71 score=4 wm=1.0 slip=10.0% gas=$0.005 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:02:16.332832 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.938 x1.7 $1.72 score=4 wm=1.0 slip=10.4% gas=$0.003 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:02:16.336181 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.933 x1.6 $1.66 score=4 wm=1.0 slip=12.4% gas=$0.005 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:02:16.339323 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.928 x1.6 $1.66 score=4 wm=1.0 slip=13.1% gas=$0.003 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:02:16.341887 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.956 x1.6 $1.66 score=4 wm=1.0 slip=13.8% gas=$0.008 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:02:16.344688 | COPY_FILL | Copied 0xf30e434a0c04fdb0116303c6e907494e4108b2f1: BUY UP@0.975 x0.6 $0.63 score=4 wm=1.0 slip=14.7% gas=$0.006 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:04:10.068429 | PAPER_SETTLED | [COPY] 0xb07a0633f2 resolved UP. Payout=$8.71 PnL=$-0.3359
2026-02-06T22:04:42.389175 | COPY_FILL | Copied PBot2: BUY UP@0.733 x3.1 $2.53 score=4 wm=2.0 slip=11.0% gas=$0.004 [CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:04:42.392548 | COPY_FILL | Copied PBot2: BUY UP@0.660 x2.3 $1.70 score=4 wm=2.0 slip=11.9% gas=$0.007 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:45PM-"
2026-02-06T22:19:34.438692 | STOP_LOSS | DOWN@0.337 x2.3 PnL=$-0.62 (-47.0%) on "Bitcoin Up or Down - February 6, 5:15PM-"
2026-02-06T22:24:51.350107 | COPY_FILL | Copied 0x0ab3a090e76fdec44: BUY UP@0.988 x0.6 $0.64 score=4 wm=1.0 slip=9.8% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:15PM-"
2026-02-06T22:24:51.353869 | COPY_FILL | Copied 0x0ab3a090e76fdec44: BUY UP@0.973 x0.6 $0.64 score=4 wm=1.0 slip=8.1% gas=$0.004 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:15PM-"
2026-02-06T22:24:53.351677 | STOP_LOSS | UP@0.664 x1.2 PnL=$-0.58 (-45.2%) on "Bitcoin Up or Down - February 6, 5:15PM-"
2026-02-06T22:36:40.096579 | COPY_FILL | Copied PBot2: BUY UP@0.690 x1.6 $1.18 score=4 wm=2.0 slip=9.5% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:00PM-"
2026-02-06T22:36:40.104211 | COPY_FILL | Copied PBot2: BUY UP@0.658 x3.2 $2.29 score=4 wm=2.0 slip=9.7% gas=$0.005 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:00PM-"
2026-02-06T22:36:40.108715 | COPY_FILL | Copied PBot2: BUY UP@0.640 x1.4 $1.02 score=4 wm=2.0 slip=14.3% gas=$0.007 [FAST CROWD DEPLETED WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:00PM-"
2026-02-06T22:36:41.823452 | PAPER_SETTLED | [COPY] 0x8de9ce75a0 resolved UP. Payout=$6.15 PnL=$1.6513
2026-02-06T23:03:59.872023 | COPY_FILL | Copied ZnegrzNirervpx: BUY UP@0.575 x2.4 $1.50 score=4 wm=1.0 slip=10.6% gas=$0.004 [CROWD WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:03:59.909841 | COPY_FILL | Copied ZnegrzNirervpx: BUY UP@0.406 x2.3 $1.02 score=5 wm=1.0 slip=6.9% gas=$0.006 [FAST PARTIAL(81%) CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:45PM-"
2026-02-06T23:04:01.588534 | STOP_LOSS | UP@0.400 x2.4 PnL=$-0.65 (-43.8%) on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:04:01.634039 | TAKE_PROFIT | UP@0.869 x2.3 PnL=+$0.75 (+73.4%) on "Bitcoin Up or Down - February 6, 5:45PM-"
2026-02-06T23:07:13.430831 | COPY_FILL | Copied 0x84b2b67922c9cd6de0d647d7cab60eab108b5e52: BUY UP@0.552 x8.1 $4.94 score=5 wm=1.0 slip=10.5% gas=$0.003 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:08:09.450789 | COPY_FILL | Copied PBot2: BUY UP@0.889 x3.7 $3.60 score=4 wm=2.3 slip=8.5% gas=$0.005 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:08:09.456282 | COPY_FILL | Copied PBot2: BUY UP@0.930 x2.7 $2.75 score=4 wm=2.3 slip=13.4% gas=$0.004 [FAST PARTIAL(76%) CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:08:09.460328 | COPY_FILL | Copied PBot2: BUY UP@0.946 x3.6 $3.79 score=4 wm=2.3 slip=8.8% gas=$0.006 [FAST CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 5:45PM-"
2026-02-06T23:18:27.898823 | COPY_FILL | Copied Lerevolution: BUY UP@0.673 x1.0 $0.76 score=4 wm=0.2 slip=8.5% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:32:24.175639 | COPY_FILL | Copied MangoTrolley7: BUY UP@0.911 x0.6 $0.60 score=1 wm=1.0 slip=7.2% gas=$0.004 [OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:00PM-"
2026-02-06T23:34:37.377732 | COPY_FILL | Copied ZnegrzNirervpx: BUY UP@0.835 x1.2 $1.10 score=4 wm=1.0 slip=7.1% gas=$0.003 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:30PM-"
2026-02-06T23:37:12.452199 | COPY_FILL | Copied VOID-PEPPER: BUY UP@0.792 x0.8 $0.69 score=4 wm=1.0 slip=8.5% gas=$0.001 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:30PM-"
2026-02-06T23:37:12.458853 | COPY_FILL | Copied VOID-PEPPER: BUY UP@0.798 x0.8 $0.69 score=4 wm=1.0 slip=9.2% gas=$0.004 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:30PM-"
2026-02-06T23:38:39.141848 | COPY_FILL | Copied PBot2: BUY DOWN@0.858 x3.5 $3.33 score=4 wm=2.3 slip=11.4% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:38:39.148906 | COPY_FILL | Copied PBot2: BUY DOWN@0.825 x3.6 $3.28 score=4 wm=2.3 slip=8.5% gas=$0.007 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:38:39.153533 | COPY_FILL | Copied PBot2: BUY DOWN@0.843 x3.5 $3.22 score=4 wm=2.3 slip=12.4% gas=$0.005 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:00PM-"
2026-02-06T23:38:40.675416 | PAPER_SETTLED | [COPY] 0xd0092f43e3 resolved DOWN. Payout=$10.59 PnL=$0.7669
2026-02-06T23:47:47.849863 | PAPER_SETTLED | [COPY] 0x3823099a1d resolved UP. Payout=$2.77 PnL=$0.2892
2026-02-07T00:04:05.154330 | COPY_FILL | Copied MangoTrolley7: BUY UP@0.821 x0.8 $0.71 score=1 wm=1.0 slip=8.0% gas=$0.005 [WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 4:00PM-"
2026-02-07T00:06:21.017667 | COPY_FILL | Copied ZnegrzNirervpx: BUY DOWN@0.783 x1.7 $1.50 score=3 wm=1.7 slip=7.2% gas=$0.007 [OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:00PM-"
2026-02-07T00:06:21.022821 | COPY_FILL | Copied ZnegrzNirervpx: BUY DOWN@0.836 x1.1 $1.04 score=3 wm=1.7 slip=8.6% gas=$0.006 [FAST DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:00PM-"
2026-02-07T00:06:21.028159 | COPY_FILL | Copied ZnegrzNirervpx: BUY DOWN@0.829 x2.3 $2.13 score=3 wm=1.7 slip=7.7% gas=$0.005 [FAST DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:00PM-"
2026-02-07T00:10:33.314104 | COPY_FILL | Copied PBot2: BUY DOWN@0.758 x3.7 $3.06 score=4 wm=2.3 slip=6.7% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:45PM-"
2026-02-07T00:10:34.920726 | PAPER_SETTLED | [COPY] 0x1e6a280b84 resolved DOWN. Payout=$3.67 PnL=$0.6075
2026-02-07T00:10:37.621492 | STOP_LOSS | UP@0.617 x1.5 PnL=$-0.42 (-31.9%) on "Bitcoin Up or Down - February 6, 4:00PM-"
2026-02-07T00:13:30.841832 | COPY_FILL | Copied wzbbb: BUY DOWN@0.938 x1.3 $1.33 score=4 wm=1.0 slip=6.8% gas=$0.007 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:00PM-"
2026-02-07T00:13:30.887104 | COPY_FILL | Copied wzbbb: BUY DOWN@0.551 x0.9 $0.52 score=2 wm=1.0 slip=6.4% gas=$0.003 [FAST OFF_HOURS] on "Bitcoin Up or Down - February 6, 7PM ET"
2026-02-07T00:13:32.588086 | TAKE_PROFIT | DOWN@0.721 x0.9 PnL=+$0.12 (+24.2%) on "Bitcoin Up or Down - February 6, 7PM ET"
2026-02-07T00:16:50.257569 | COPY_FILL | Copied jxckkk: BUY DOWN@0.346 x5.4 $1.92 score=5 wm=1.0 slip=15.4% gas=$0.002 [PARTIAL(65%) CROWD WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down on February 7?"
2026-02-07T00:17:51.398000 | PAPER_SETTLED | [COPY] 0x2a55f9a9cb resolved DOWN. Payout=$6.46 PnL=$0.4683
2026-02-07T00:20:14.995868 | COPY_FILL | Copied jonnyjst: BUY DOWN@0.902 x1.9 $1.88 score=4 wm=1.0 slip=7.4% gas=$0.001 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:00PM-"
2026-02-07T00:20:15.002244 | COPY_FILL | Copied jonnyjst: BUY DOWN@0.913 x5.3 $5.37 score=4 wm=1.0 slip=10.0% gas=$0.004 [FAST CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 6:45PM-"
2026-02-07T00:34:34.067266 | TAKE_PROFIT | DOWN@0.375 x5.4 PnL=+$0.07 (+3.8%) on "Bitcoin Up or Down on February 7?"
2026-02-07T00:36:26.755092 | COPY_FILL | Copied Bittercoin: BUY DOWN@0.488 x5.6 $2.77 score=4 wm=1.0 slip=8.5% gas=$0.005 [CROWD OFF_HOURS] on "Bitcoin Up or Down on February 7?"
2026-02-07T00:36:26.761731 | COPY_FILL | Copied Bittercoin: BUY DOWN@0.441 x1.7 $0.78 score=4 wm=1.0 slip=10.4% gas=$0.006 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down on February 7?"
2026-02-07T00:37:58.369581 | COPY_FILL | Copied 0x6c670Bbf5E03dBE7B352E5f252E8f48FD033A813-1767364297316: BUY DOWN@0.622 x2.7 $1.87 score=4 wm=1.0 slip=9.5% gas=$0.003 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:15PM-"
2026-02-07T00:37:59.977960 | PAPER_SETTLED | [COPY] 0xf2a764d1d9 resolved DOWN. Payout=$2.73 PnL=$0.8616
2026-02-07T00:38:27.686444 | COPY_FILL | Copied ZnegrzNirervpx: BUY DOWN@0.879 x3.6 $3.54 score=4 wm=2.3 slip=9.9% gas=$0.004 [CROWD WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:38:27.702639 | COPY_EXIT | Exited with ZnegrzNirervpx: SELL DOWN@0.764 x3.6 PnL=-$1.0334 on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:42:18.223956 | COPY_FILL | Copied mokafat: BUY UP@0.165 x29.4 $5.33 score=6 wm=1.0 slip=5.9% gas=$0.005 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:42:18.276224 | COPY_FILL | Copied mokafat: BUY UP@0.430 x7.9 $3.75 score=5 wm=1.0 slip=10.4% gas=$0.007 [FAST PARTIAL(70%) CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:15PM-"
2026-02-07T00:42:19.957611 | STOP_LOSS | UP@0.087 x29.4 PnL=$-3.04 (-57.0%) on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:42:20.006126 | PAPER_SETTLED | [COPY] 0xf2a764d1d9 resolved DOWN. Payout=$0.00 PnL=$-3.7505
2026-02-07T00:42:21.189329 | COPY_FILL | Copied PBot2: BUY DOWN@0.915 x2.0 $2.02 score=4 wm=2.4 slip=10.3% gas=$0.003 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:42:21.194955 | COPY_FILL | Copied PBot2: BUY DOWN@0.930 x3.6 $3.69 score=4 wm=2.4 slip=12.0% gas=$0.005 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:50:54.458623 | COPY_FILL | Copied jonnyjst: BUY UP@0.834 x2.0 $1.85 score=4 wm=1.0 slip=6.9% gas=$0.007 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:45PM-"
2026-02-07T00:50:54.466155 | COPY_FILL | Copied jonnyjst: BUY DOWN@0.990 x1.7 $1.84 score=4 wm=1.0 slip=10.5% gas=$0.005 [FAST CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T00:50:56.109597 | STOP_LOSS | UP@0.647 x2.0 PnL=$-0.68 (-37.0%) on "Bitcoin Up or Down - February 6, 7:45PM-"
2026-02-07T01:01:48.135051 | COPY_FILL | Copied MuddyWaters: BUY DOWN@0.810 x1.6 $1.47 score=4 wm=1.0 slip=6.5% gas=$0.004 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 7:30PM-"
2026-02-07T01:09:20.384658 | COPY_FILL | Copied ZnegrzNirervpx: BUY UP@0.503 x1.6 $0.88 score=4 wm=1.1 slip=9.4% gas=$0.006 [CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:09:20.394484 | COPY_FILL | Copied ZnegrzNirervpx: BUY UP@0.517 x1.0 $0.58 score=4 wm=1.1 slip=10.1% gas=$0.005 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:09:43.573639 | TAKE_PROFIT | UP@0.658 x2.6 PnL=+$0.07 (+4.6%) on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:13:15.367497 | COPY_FILL | Copied PBot2: BUY DOWN@0.779 x3.6 $3.08 score=4 wm=2.4 slip=11.4% gas=$0.007 [CROWD WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:13:15.376822 | COPY_FILL | Copied PBot2: BUY DOWN@0.736 x3.5 $2.86 score=4 wm=2.4 slip=13.3% gas=$0.007 [FAST CROWD DEPLETED WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:13:15.384774 | COPY_FILL | Copied PBot2: BUY DOWN@0.666 x3.6 $2.63 score=4 wm=2.4 slip=10.9% gas=$0.004 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:13:15.392752 | COPY_FILL | Copied PBot2: BUY DOWN@0.715 x2.0 $1.58 score=4 wm=2.4 slip=14.2% gas=$0.007 [FAST CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:13:16.847954 | STOP_LOSS | DOWN@0.425 x12.7 PnL=$-5.30 (-52.2%) on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:18:50.271220 | COPY_FILL | Copied Border-collie: BUY UP@0.865 x2.8 $2.64 score=4 wm=1.0 slip=10.8% gas=$0.003 [PARTIAL(50%) CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:15PM-"
2026-02-07T01:18:50.281824 | COPY_FILL | Copied Border-collie: BUY UP@0.374 x4.3 $1.76 score=5 wm=1.0 slip=6.7% gas=$0.007 [FAST CROWD OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:00PM-"
2026-02-07T01:18:51.783376 | STOP_LOSS | UP@0.660 x2.8 PnL=$-1.00 (-37.8%) on "Bitcoin Up or Down - February 6, 8:15PM-"
2026-02-07T01:23:28.240744 | COPY_FILL | Copied rorynobisme: BUY UP@0.524 x9.0 $4.82 score=2 wm=1.0 slip=4.8% gas=$0.006 [OFF_HOURS] on "Bitcoin Up or Down - February 1, 6AM ET"
2026-02-07T01:23:29.785644 | PAPER_SETTLED | [COPY] 0xbef8c18981 resolved UP. Payout=$9.01 PnL=$4.1885
2026-02-07T01:24:55.096300 | COPY_FILL | Copied GGMU9527: BUY UP@0.711 x6.7 $5.22 score=1 wm=1.0 slip=8.2% gas=$0.005 [OFF_HOURS] on "Bitcoin Up or Down - February 6, 8:15AM-"
2026-02-07T01:24:56.658765 | PAPER_SETTLED | [COPY] 0x56f2e1d4a6 resolved DOWN. Payout=$0.00 PnL=$-5.2211
2026-02-07T01:27:34.702415 | COPY_FILL | Copied Vivianned: BUY DOWN@0.530 x8.9 $4.82 score=2 wm=1.0 slip=6.0% gas=$0.007 [OFF_HOURS] on "Bitcoin Up or Down - February 3, 11PM ET"
2026-02-07T01:27:36.205983 | PAPER_SETTLED | [COPY] 0x0805f35675 resolved DOWN. Payout=$8.90 PnL=$4.0825
2026-02-07T01:27:55.742505 | COPY_FILL | Copied olinnihilh: BUY DOWN@0.540 x8.8 $4.84 score=2 wm=1.0 slip=8.0% gas=$0.005 [WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down - February 3, 4PM ET"
2026-02-07T01:27:57.331902 | PAPER_SETTLED | [COPY] 0x3644be3351 resolved DOWN. Payout=$8.77 PnL=$3.9341
2026-02-07T01:30:58.590716 | COPY_FILL | Copied UpWind: BUY DOWN@0.831 x1.1 $1.05 score=1 wm=1.0 slip=6.5% gas=$0.004 [OFF_HOURS] on "Bitcoin Up or Down - February 5, 2:00PM-"
2026-02-07T01:31:00.029564 | PAPER_SETTLED | [COPY] 0x586b4dbf65 resolved DOWN. Payout=$1.14 PnL=$0.0897
2026-02-07T01:31:44.956607 | COPY_FILL | Copied A P: BUY DOWN@0.534 x1.7 $0.94 score=5 wm=1.0 slip=9.1% gas=$0.006 [CROWD WIDE_SPREAD OFF_HOURS] on "Bitcoin Up or Down on February 7?"
2026-02-07T01:31:44.965074 | COPY_FILL | Copied A P: BUY DOWN@0.549 x1.4 $0.81 score=5 wm=1.0 slip=12.1% gas=$0.004 [FAST PARTIAL(42%) CROWD DEPLETED OFF_HOURS] on "Bitcoin Up or Down on February 7?"
2026-02-07T01:34:42.183032 | COPY_FILL | Copied consectet: BUY UP@0.538 x2.8 $1.53 score=2 wm=1.0 slip=7.7% gas=$0.007 [OFF_HOURS] on "Bitcoin Up or Down - February 2, 11AM ET"
2026-02-07T01:34:43.662598 | PAPER_SETTLED | [COPY] 0x843c4abd31 resolved DOWN. Payout=$0.00 PnL=$-1.5330
2026-02-07T01:37:21.102250 | COPY_FILL | Copied leonfrit: BUY DOWN@0.531 x4.6 $2.49 score=2 wm=1.0 slip=6.2% gas=$0.007 [PARTIAL(51%) OFF_HOURS] on "Bitcoin Up or Down - February 4, 4PM ET"

... [TRUNCATED — 1045 total lines]


================================================================================
SECTION: PERFORMANCE SUMMARY
================================================================================
{
  "starting_balance": 50.0,
  "current_balance": 54.56,
  "total_return_pct": 9.13,
  "realized_pnl": 4.56,
  "total_trades": 15,
  "total_buy_fills": 15,
  "total_sell_fills": 10,
  "winning_trades": 8,
  "losing_trades": 2,
  "win_rate_pct": 80.0,
  "total_fees_paid": 0.8363,
  "take_profit_exits": 8,
  "stop_loss_exits": 1,
  "whale_exit_copies": 1,
  "open_positions": 0,
  "closed_positions": 7,
  "unique_whales_copied": [
    "Bot9735",
    "Trik7895"
  ],
  "unique_markets_traded": [
    "Bitcoin Up or Down - February 8, 2:00PM-",
    "Bitcoin Up or Down - February 8, 1:45PM-",
    "Bitcoin Up or Down - February 8, 2:30PM-",
    "Bitcoin Up or Down - February 8, 1:30PM-",
    "Bitcoin Up or Down - February 8, 3:00PM-",
    "Bitcoin Up or Down - February 8, 2:45PM-"
  ]
}